[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : NUM_CMDS
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "NEXT"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "PREV"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "UPDATE"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "HELP"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "EXIT"
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handler_index ( form_t * form , char * buf )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = char * 
var: p (p) = buf
var: char * p (p) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'cmd_buf [ MAX_CMD_SIZE ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [cmd_buf] = char * 
[C-t-3] sym_dict [cmd_buf [ MAX_CMD_SIZE ]] = char 
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => * p == '*'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => * p
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '*'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => * p == '*'
=> ['* p', "'*'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : * p
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['* p']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['* p']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['* p']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['* p']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['* p']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.UnaryOperatorContext'>, <class 'CParser.CParser.CastExpressionContext'>] ['*', 'p']
-------<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p']
--------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p']
---------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p']
FOUND IT! [2.2]  char * : p
Resolved type: [2.3]  char : p
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => p - buf < 2
[0] <class 'CParser.CParser.ShiftExpressionContext'> => p - buf
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 2
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => p - buf < 2
=> ['p - buf', '2']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : p - buf
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['p - buf']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.MultiplicativeExpressionContext'>] ['p', '-', 'buf']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['p']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p']
FOUND IT! [1.2]  char * : p
Resolved type: [1.3]  char * : p
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { p ++ ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( * p == '*' && p - buf < 2 ) { p ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { p ++ ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: int i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < NUM_CMDS
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => NUM_CMDS
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < NUM_CMDS
=> ['i', 'NUM_CMDS']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * 
var: tlv4 (tlv4) = cmd_buf
var: void * tlv4 (tlv4) = cmd_buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = p
var: void * tlv3 (tlv3) = p
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv9 = cmd_lbls [ i ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = const char * 
var: tlv2 (tlv2) = cgc_strlen ( tlv9 )
var: cgc_size_t tlv2 (tlv2) = cgc_strlen ( tlv9 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; }
Assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv9 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } ]
Assigns = [('void *', 'tlv4', '', 'cmd_buf'), ('void *', 'tlv3', '', 'p')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 = cmd_lbls [ i ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = const char * 
var: cmd_buf  (cmd_buf [ cgc_strlen ( tlv8 ) ]) = '\0'
var: UNDEF cmd_buf  (cmd_buf [ cgc_strlen ( tlv8 ) ]) = '\0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; }
Assigns = [('UNDEF', 'cmd_buf ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'")]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 = cmd_buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = cmd_lbls [ i ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv10 = cmd_lbls [ i ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = const char * 
var: tlv5 (tlv5) = cgc_strlen ( tlv10 )
var: cgc_size_t tlv5 (tlv5) = cgc_strlen ( tlv10 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; }
Assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv10 )')]
Compares = []
var: tlv1 (tlv1) = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 )
var: int tlv1 (tlv1) = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } ]
Assigns = [('int', 'tlv1', '', 'cgc_strncasecmp ( tlv7 , tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return i ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { return i ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return i ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { return i ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int i ; char * p ; p = buf ; char cmd_buf [ MAX_CMD_SIZE ] ; while ( * p == '*' && p - buf < 2 ) { p ++ ; } for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } return - 1 ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( * p == '*' && p - buf < 2 ) { p ++ ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } ]
Assigns = [('char *', 'p', '', 'buf')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_handler_index ( form_t * form , char * buf ) { int i ; char * p ; p = buf ; char cmd_buf [ MAX_CMD_SIZE ] ; while ( * p == '*' && p - buf < 2 ) { p ++ ; } for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int i ; char * p ; p = buf ; char cmd_buf [ MAX_CMD_SIZE ] ; while ( * p == '*' && p - buf < 2 ) { p ++ ; } for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } return - 1 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_is_cmd ( form_t * form , char * buf )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 [ ] = "**"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv4] = const char * 
[C-t-2] sym_dict [tlv4 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 = buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = 2
var: cgc_size_t tlv2 (tlv2) = 2
var: tlv1 (tlv1) = cgc_strncmp ( tlv4 , tlv3 , tlv2 )
var: int tlv1 (tlv1) = cgc_strncmp ( tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('cgc_size_t', 'tlv2', '', '2'), ('int', 'tlv1', '', 'cgc_strncmp ( tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => cgc_handler_index ( form , buf ) >= 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => cgc_handler_index ( form , buf )
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => cgc_handler_index ( form , buf ) >= 0
=> ['cgc_handler_index ( form , buf )', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : cgc_handler_index ( form , buf )
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cgc_handler_index ( form , buf )']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cgc_handler_index ( form , buf )']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cgc_handler_index ( form , buf )']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cgc_handler_index ( form , buf )']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cgc_handler_index ( form , buf )']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ArgumentExpressionListContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cgc_handler_index', '(', 'form , buf', ')']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
Resolved type: [1.3]  UNDEF : 0
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv1 ; { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 ) { return 0 ; } return cgc_handler_index ( form , buf ) >= 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 ) { return 0 ; } ]
Assigns = []
Compares = [('UNDEF', '', '', <class 'CParser.CParser.ShiftExpressionContext'>, 'cgc_handler_index ( form , buf )'), ('UNDEF', '', '', <class 'CParser.CParser.ShiftExpressionContext'>, '0')]
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_is_cmd ( form_t * form , char * buf ) { int tlv1 ; { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 ) { return 0 ; } return cgc_handler_index ( form , buf ) >= 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv1 ; { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 ) { return 0 ; } return cgc_handler_index ( form , buf ) >= 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'page_complete ( form_t * form )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'question_t * cur'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [cur] = question_t * 
var: cur (cur) = form -> cur_page -> questions
var: question_t * cur (cur) = form -> cur_page -> questions
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int completed'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [completed] = int 
var: completed (completed) = 1
var: int completed (completed) = 1
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur != NULL
=> ['cur', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cur']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur -> answer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer == NULL
=> ['cur -> answer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur -> answer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur -> answer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur -> answer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur -> answer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur -> answer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur -> answer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur -> answer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cur', '->', 'answer']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ! cur -> optional && cur -> answer == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: completed (completed) = 0
var: int completed (completed) = 0
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { completed = 0 ; break ; }
Assigns = [('int', 'completed', '', '0')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ! cur -> optional && cur -> answer == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { completed = 0 ; break ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: cur (cur) = cur -> next
var: question_t * cur (cur) = cur -> next
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cur = cur -> next ; }
Assigns = [('question_t *', 'cur', '', 'cur -> next')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { completed = 0 ; break ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cur = cur -> next ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } ]
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question == NULL
=> ['form -> cur_question', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { question_t * cur ; cur = form -> cur_page -> questions ; int completed ; completed = 1 ; while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } return completed && form -> cur_question == NULL ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } ]
Assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
Compares = [('form_t *', '', '', <class 'CParser.CParser.RelationalExpressionContext'>, 'form -> cur_question'), ('form_t *', '', '', <class 'CParser.CParser.RelationalExpressionContext'>, 'NULL')]
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int page_complete ( form_t * form ) { question_t * cur ; cur = form -> cur_page -> questions ; int completed ; completed = 1 ; while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } return completed && form -> cur_question == NULL ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { question_t * cur ; cur = form -> cur_page -> questions ; int completed ; completed = 1 ; while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } return completed && form -> cur_question == NULL ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_print_title ( form_t * form )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 = form -> cur_page -> title'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 [ ] = "Fin"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv3] = const char * 
[C-t-2] sym_dict [tlv3 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = 3
var: cgc_size_t tlv2 (tlv2) = 3
var: tlv1 (tlv1) = cgc_strncmp ( tlv4 , tlv3 , tlv2 )
var: int tlv1 (tlv1) = cgc_strncmp ( tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('cgc_size_t', 'tlv2', '', '3'), ('int', 'tlv1', '', 'cgc_strncmp ( tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\nFinal Questions\n" ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "\nFinal Questions\n" ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\nFinal Questions\n" ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv1 ; { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static void cgc_print_title ( form_t * form ) { int tlv1 ; { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv1 ; { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_cmd ( form_t * form , char * buf )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * arg'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [arg] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv9 = buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = const char * 
var: tlv3 (tlv3) = cgc_strlen ( tlv9 ) + 1
var: cgc_size_t tlv3 (tlv3) = cgc_strlen ( tlv9 ) + 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; }
Assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv9 ) + 1')]
Compares = []
var: arg (arg) = cgc_malloc ( tlv3 )
var: char * arg (arg) = cgc_malloc ( tlv3 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } ]
Assigns = [('char *', 'arg', '', 'cgc_malloc ( tlv3 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => arg == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => arg
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => arg == NULL
=> ['arg', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : arg
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['arg']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['arg']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['arg']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['arg']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['arg']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['arg']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['arg']
FOUND IT! [2.2]  char * : arg
Resolved type: [2.3]  char * : arg
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ arg == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( arg == NULL ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char * 
var: tlv2 (tlv2) = arg
var: char * tlv2 (tlv2) = arg
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 = buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; }
Assigns = [('char *', 'tlv2', '', 'arg')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 = buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = const char * 
var: arg  (arg [ cgc_strlen ( tlv8 ) ]) = '\0'
var: UNDEF arg  (arg [ cgc_strlen ( tlv8 ) ]) = '\0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; }
Assigns = [('UNDEF', 'arg ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'")]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * cmd'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [cmd] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = char * * 
var: tlv5 (tlv5) = & arg
var: char * * tlv5 (tlv5) = & arg
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 [ ] = " "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv4] = const char * 
[C-t-2] sym_dict [tlv4 [ ]] = const char 
var: cmd (cmd) = cgc_strsep ( tlv5 , tlv4 )
var: char * cmd (cmd) = cgc_strsep ( tlv5 , tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }
Assigns = [('char * *', 'tlv5', '', '& arg'), ('char *', 'cmd', '', 'cgc_strsep ( tlv5 , tlv4 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'form_t * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = form_t * 
var: tlv7 (tlv7) = form
var: form_t * tlv7 (tlv7) = form
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = char * 
var: tlv6 (tlv6) = cmd
var: char * tlv6 (tlv6) = cmd
var: i (i) = cgc_handler_index ( tlv7 , tlv6 )
var: int i (i) = cgc_handler_index ( tlv7 , tlv6 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }
Assigns = [('form_t *', 'tlv7', '', 'form'), ('char *', 'tlv6', '', 'cmd'), ('int', 'i', '', 'cgc_handler_index ( tlv7 , tlv6 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < 0
=> ['i', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ i < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = i
var: int ret (ret) = i
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = i ; goto out ; }
Assigns = [('int', 'ret', '', 'i')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( i < 0 ) { ret = i ; goto out ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = i ; goto out ; } ]
var: ret (ret) = form -> handlers [ i ] ( form , arg )
var: int ret (ret) = form -> handlers [ i ] ( form , arg )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.LabeledStatementContext'> [start? False]
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.LabeledStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cmd != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cmd
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cmd != NULL
=> ['cmd', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cmd
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cmd']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cmd']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cmd']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cmd']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cmd']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cmd']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cmd']
FOUND IT! [2.2]  char * : cmd
Resolved type: [2.3]  char * : cmd
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ cmd != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( cmd )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_free ( cmd ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( cmd != NULL ) { cgc_free ( cmd ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_free ( cmd ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * arg ; { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } int ret ; if ( arg == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } char * cmd ; { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } int i ; { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } if ( i < 0 ) { ret = i ; goto out ; } ret = form -> handlers [ i ] ( form , arg ) ; out : if ( cmd != NULL ) { cgc_free ( cmd ) ; } return ret ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( arg == NULL ) { return - 1 ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } ]
 6 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( i < 0 ) { ret = i ; goto out ; } ]
 7 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( cmd != NULL ) { cgc_free ( cmd ) ; } ]
Assigns = [('int', 'ret', '', 'form -> handlers [ i ] ( form , arg )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_handle_cmd ( form_t * form , char * buf ) { char * arg ; { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } int ret ; if ( arg == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } char * cmd ; { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } int i ; { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } if ( i < 0 ) { ret = i ; goto out ; } ret = form -> handlers [ i ] ( form , arg ) ; out : if ( cmd != NULL ) { cgc_free ( cmd ) ; } return ret ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * arg ; { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } int ret ; if ( arg == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } char * cmd ; { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } int i ; { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } if ( i < 0 ) { ret = i ; goto out ; } ret = form -> handlers [ i ] ( form , arg ) ; out : if ( cmd != NULL ) { cgc_free ( cmd ) ; } return ret ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_answer ( form_t * form , char * input )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = input [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['input']
[enterParameterDeclaration] char * : input
sym_dict [input] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ! form -> cur_question -> validator ( input ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> answer != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question -> answer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> answer != NULL
=> ['form -> cur_question -> answer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question -> answer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question -> answer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question -> answer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question -> answer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question -> answer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question -> answer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question -> answer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question', '->', 'answer']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_question -> answer != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * 
var: tlv4 (tlv4) = form -> cur_question -> answer
var: void * tlv4 (tlv4) = form -> cur_question -> answer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv4 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; }
Assigns = [('void *', 'tlv4', '', 'form -> cur_question -> answer')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 = input'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = const char * 
var: tlv3 (tlv3) = cgc_strlen ( tlv5 ) + 1
var: cgc_size_t tlv3 (tlv3) = cgc_strlen ( tlv5 ) + 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; }
Assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv5 ) + 1')]
Compares = []
var: form -> cur_question -> answer (form -> cur_question -> answer) = cgc_malloc ( tlv3 )
var: UNDEF form -> cur_question -> answer (form -> cur_question -> answer) = cgc_malloc ( tlv3 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } ]
Assigns = [('UNDEF', 'form -> cur_question -> answer', '', 'cgc_malloc ( tlv3 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> answer == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question -> answer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> answer == NULL
=> ['form -> cur_question -> answer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question -> answer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question -> answer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question -> answer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question -> answer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question -> answer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question -> answer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question -> answer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question', '->', 'answer']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_question -> answer == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_question -> answer == NULL ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char * 
var: tlv2 (tlv2) = form -> cur_question -> answer
var: char * tlv2 (tlv2) = form -> cur_question -> answer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 = input'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }
Assigns = [('char *', 'tlv2', '', 'form -> cur_question -> answer')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } if ( form -> cur_question -> answer == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } return 0 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_question -> answer == NULL ) { return - 1 ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_handle_answer ( form_t * form , char * input ) { if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } if ( form -> cur_question -> answer == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } if ( form -> cur_question -> answer == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_next_question ( form_t * form )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question == NULL
=> ['form -> cur_question', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_question == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_question == NULL ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> next == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question -> next
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> next == NULL
=> ['form -> cur_question -> next', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question -> next
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question -> next']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question -> next']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question -> next']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question -> next']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question -> next']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question -> next']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question', '->', 'next']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_question -> next == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: form -> cur_page -> completed (form -> cur_page -> completed) = 1
var: UNDEF form -> cur_page -> completed (form -> cur_page -> completed) = 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form -> cur_page -> completed = 1 ; }
Assigns = [('UNDEF', 'form -> cur_page -> completed', '', '1')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_question -> next == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { form -> cur_page -> completed = 1 ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: form -> cur_question (form -> cur_question) = form -> cur_question -> next
var: UNDEF form -> cur_question (form -> cur_question) = form -> cur_question -> next
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form -> cur_question = form -> cur_question -> next ; }
Assigns = [('UNDEF', 'form -> cur_question', '', 'form -> cur_question -> next')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form -> cur_page -> completed = 1 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form -> cur_question = form -> cur_question -> next ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( form -> cur_question == NULL ) { return - 1 ; } if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } return 0 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_question == NULL ) { return - 1 ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_next_question ( form_t * form ) { if ( form -> cur_question == NULL ) { return - 1 ; } if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( form -> cur_question == NULL ) { return - 1 ; } if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_print_page ( form_t * form )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'question_t * cur'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [cur] = question_t * 
var: cur (cur) = form -> cur_page -> questions
var: question_t * cur (cur) = form -> cur_page -> questions
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = form -> cur_page -> title'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 [ ] = "Edu"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv5] = const char * 
[C-t-2] sym_dict [tlv5 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = cgc_size_t 
var: tlv4 (tlv4) = 3
var: cgc_size_t tlv4 (tlv4) = 3
var: tlv1 (tlv1) = cgc_strncmp ( tlv6 , tlv5 , tlv4 )
var: int tlv1 (tlv1) = cgc_strncmp ( tlv6 , tlv5 , tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; }
Assigns = [('cgc_size_t', 'tlv4', '', '3'), ('int', 'tlv1', '', 'cgc_strncmp ( tlv6 , tlv5 , tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv9 = form -> cur_page -> title'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 [ ] = "Emp"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv8] = const char * 
[C-t-2] sym_dict [tlv8 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = cgc_size_t 
var: tlv7 (tlv7) = 3
var: cgc_size_t tlv7 (tlv7) = 3
var: tlv2 (tlv2) = cgc_strncmp ( tlv9 , tlv8 , tlv7 )
var: int tlv2 (tlv2) = cgc_strncmp ( tlv9 , tlv8 , tlv7 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; }
Assigns = [('cgc_size_t', 'tlv7', '', '3'), ('int', 'tlv2', '', 'cgc_strncmp ( tlv9 , tlv8 , tlv7 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
=> ['tlv2', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [2.2]  int : tlv2
Resolved type: [2.3]  int : tlv2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv12 = form -> cur_page -> title'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv11 [ ] = "Fin"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv11] = const char * 
[C-t-2] sym_dict [tlv11 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = cgc_size_t 
var: tlv10 (tlv10) = 3
var: cgc_size_t tlv10 (tlv10) = 3
var: tlv3 (tlv3) = cgc_strncmp ( tlv12 , tlv11 , tlv10 )
var: int tlv3 (tlv3) = cgc_strncmp ( tlv12 , tlv11 , tlv10 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; }
Assigns = [('cgc_size_t', 'tlv10', '', '3'), ('int', 'tlv3', '', 'cgc_strncmp ( tlv12 , tlv11 , tlv10 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv3
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 == 0
=> ['tlv3', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv3
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv3']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv3']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv3']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv3']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv3']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv3']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv3']
FOUND IT! [2.2]  int : tlv3
Resolved type: [2.3]  int : tlv3
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv3 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv3 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur != NULL
=> ['cur', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cur']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
var: cur (cur) = cur -> next
var: question_t * cur (cur) = cur -> next
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur -> answer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer != NULL
=> ['cur -> answer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur -> answer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur -> answer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur -> answer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur -> answer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur -> answer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur -> answer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur -> answer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cur', '->', 'answer']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ cur -> answer != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ cur -> answer != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s=\n" , cur -> title ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s=\n" , cur -> title ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { question_t * cur ; cur = form -> cur_page -> questions ; int tlv1 ; { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } ]
 2 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } ]
Assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static void cgc_print_page ( form_t * form ) { question_t * cur ; cur = form -> cur_page -> questions ; int tlv1 ; { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { question_t * cur ; cur = form -> cur_page -> questions ; int tlv1 ; { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_prompt_next ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\nType **next to continue\n" ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static void cgc_prompt_next ( void ) { cgc_printf ( "\nType **next to continue\n" ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\nType **next to continue\n" ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_next_page ( form_t * form )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_page
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page == NULL
=> ['form -> cur_page', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_page
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_page']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_page']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_page']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_page']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_page']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_page']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_page']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page == NULL ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> next == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_page -> next
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> next == NULL
=> ['form -> cur_page -> next', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_page -> next
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_page -> next']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_page -> next']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_page -> next']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_page -> next']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_page -> next']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_page -> next']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_page', '->', 'next']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> next == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page -> next == NULL ) { return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 1 ; } ]
var: form -> cur_page (form -> cur_page) = form -> cur_page -> next
var: UNDEF form -> cur_page (form -> cur_page) = form -> cur_page -> next
var: form -> cur_question (form -> cur_question) = form -> cur_page -> questions
var: UNDEF form -> cur_question (form -> cur_question) = form -> cur_page -> questions
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> next == NULL ) { return 1 ; } form -> cur_page = form -> cur_page -> next ; form -> cur_question = form -> cur_page -> questions ; return 0 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page == NULL ) { return - 1 ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page -> next == NULL ) { return 1 ; } ]
Assigns = [('UNDEF', 'form -> cur_page', '', 'form -> cur_page -> next'), ('UNDEF', 'form -> cur_question', '', 'form -> cur_page -> questions')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_next_page ( form_t * form ) { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> next == NULL ) { return 1 ; } form -> cur_page = form -> cur_page -> next ; form -> cur_question = form -> cur_page -> questions ; return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> next == NULL ) { return 1 ; } form -> cur_page = form -> cur_page -> next ; form -> cur_question = form -> cur_page -> questions ; return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_print_next_title ( form_t * form )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> next -> title == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_page -> next -> title
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> next -> title == NULL
=> ['form -> cur_page -> next -> title', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_page -> next -> title
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_page -> next -> title']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_page -> next -> title']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_page -> next -> title']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_page -> next -> title']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_page -> next -> title']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_page -> next -> title']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_page', '->', 'next', '->', 'title']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> next -> title == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s" , form -> ending ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> next -> title == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "%s" , form -> ending ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 = form -> cur_page -> next -> title'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 [ ] = "Fin"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv3] = const char * 
[C-t-2] sym_dict [tlv3 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = 3
var: cgc_size_t tlv2 (tlv2) = 3
var: tlv1 (tlv1) = cgc_strncmp ( tlv4 , tlv3 , tlv2 )
var: int tlv1 (tlv1) = cgc_strncmp ( tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('cgc_size_t', 'tlv2', '', '3'), ('int', 'tlv1', '', 'cgc_strncmp ( tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\nFinal Questions\n" ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "\nFinal Questions\n" ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\nFinal Questions\n" ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s" , form -> ending ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static void cgc_print_next_title ( form_t * form ) { if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_prompt_q ( question_t * q )')]
ParameterDeclaration : type = question_t *, var = q [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['q']
[enterParameterDeclaration] question_t * : q
sym_dict [q] = question_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => q -> hint != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => q -> hint
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => q -> hint != NULL
=> ['q -> hint', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : q -> hint
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['q -> hint']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['q -> hint']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['q -> hint']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['q -> hint']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['q -> hint']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['q -> hint']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['q', '->', 'hint']
FOUND IT! [2.2]  question_t * : q
Resolved type: [2.3]  question_t * : q
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ q -> hint != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ q -> hint != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s: " , q -> title ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s: " , q -> title ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static void cgc_prompt_q ( question_t * q ) { if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_next ( form_t * form , char * arg )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = arg [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['arg']
[enterParameterDeclaration] char * : arg
sym_dict [arg] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> title == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_page -> title
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> title == NULL
=> ['form -> cur_page -> title', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_page -> title
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_page -> title']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_page -> title']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_page -> title']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_page -> title']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_page -> title']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_page -> title']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_page', '->', 'title']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> title == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page -> title == NULL ) { return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ! form -> cur_page -> completed ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_print_next_title'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( form )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'form_t * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = form_t * 
var: tlv1 (tlv1) = form
var: form_t * tlv1 (tlv1) = form
var: ret (ret) = cgc_next_page ( tlv1 )
var: int ret (ret) = cgc_next_page ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; }
Assigns = [('form_t *', 'tlv1', '', 'form'), ('int', 'ret', '', 'cgc_next_page ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => ret < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => ret
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => ret < 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : ret
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [1.2]  int : ret
Resolved type: [1.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret < 0 ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 2 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { return 2 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 2 ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question != NULL
=> ['form -> cur_question', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> next != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question -> next
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> next != NULL
=> ['form -> cur_question -> next', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question -> next
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question -> next']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question -> next']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question -> next']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question -> next']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question -> next']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question -> next']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question', '->', 'next']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> answer != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question -> answer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question -> answer != NULL
=> ['form -> cur_question -> answer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question -> answer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question -> answer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question -> answer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question -> answer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question -> answer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question -> answer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question -> answer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question', '->', 'answer']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: form -> cur_question (form -> cur_question) = form -> cur_question -> next
var: UNDEF form -> cur_question (form -> cur_question) = form -> cur_question -> next
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form -> cur_question = form -> cur_question -> next ; }
Assigns = [('UNDEF', 'form -> cur_question', '', 'form -> cur_question -> next')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form -> cur_question = form -> cur_question -> next ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; if ( form -> cur_page -> title == NULL ) { return 1 ; } if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 2 ; } while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } return 1 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page -> title == NULL ) { return 1 ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret < 0 ) { return - 1 ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { return 2 ; } ]
 5 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_handle_next ( form_t * form , char * arg ) { int ret ; if ( form -> cur_page -> title == NULL ) { return 1 ; } if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 2 ; } while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; if ( form -> cur_page -> title == NULL ) { return 1 ; } if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 2 ; } while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } return 1 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_exit ( form_t * form , char * arg )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = arg [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['arg']
[enterParameterDeclaration] char * : arg
sym_dict [arg] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "Thank you!\n" ) ; cgc_exit ( 0 ) ; return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_handle_exit ( form_t * form , char * arg ) { cgc_printf ( "Thank you!\n" ) ; cgc_exit ( 0 ) ; return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "Thank you!\n" ) ; cgc_exit ( 0 ) ; return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_help ( form_t * form , char * arg )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = arg [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['arg']
[enterParameterDeclaration] char * : arg
sym_dict [arg] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s" , form -> help ) ; return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_handle_help ( form_t * form , char * arg ) { cgc_printf ( "%s" , form -> help ) ; return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s" , form -> help ) ; return 1 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_prev ( form_t * form , char * arg )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = arg [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['arg']
[enterParameterDeclaration] char * : arg
sym_dict [arg] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_page
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page == NULL
=> ['form -> cur_page', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_page
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_page']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_page']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_page']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_page']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_page']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_page']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_page']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page == NULL ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> prev == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_page -> prev
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> prev == NULL
=> ['form -> cur_page -> prev', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_page -> prev
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_page -> prev']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_page -> prev']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_page -> prev']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_page -> prev']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_page -> prev']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_page -> prev']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_page', '->', 'prev']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> prev == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_print_title'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( form )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_print_title ( form ) ; return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_print_title ( form ) ; return 0 ; } ]
var: form -> cur_page (form -> cur_page) = form -> cur_page -> prev
var: UNDEF form -> cur_page (form -> cur_page) = form -> cur_page -> prev
var: form -> cur_question (form -> cur_question) = form -> cur_page -> questions
var: UNDEF form -> cur_question (form -> cur_question) = form -> cur_page -> questions
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } form -> cur_page = form -> cur_page -> prev ; form -> cur_question = form -> cur_page -> questions ; return 1 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page == NULL ) { return - 1 ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } ]
Assigns = [('UNDEF', 'form -> cur_page', '', 'form -> cur_page -> prev'), ('UNDEF', 'form -> cur_question', '', 'form -> cur_page -> questions')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_handle_prev ( form_t * form , char * arg ) { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } form -> cur_page = form -> cur_page -> prev ; form -> cur_question = form -> cur_page -> questions ; return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } form -> cur_page = form -> cur_page -> prev ; form -> cur_question = form -> cur_page -> questions ; return 1 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_update ( form_t * form , char * arg )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = arg [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['arg']
[enterParameterDeclaration] char * : arg
sym_dict [arg] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'question_t * cur'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [cur] = question_t * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * input_buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [input_buf] = char * 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ! form -> cur_page -> completed ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => arg == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => arg
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => arg == NULL
=> ['arg', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : arg
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['arg']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['arg']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['arg']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['arg']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['arg']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['arg']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['arg']
FOUND IT! [2.2]  char * : arg
Resolved type: [2.3]  char * : arg
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ arg == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( arg == NULL ) { return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 1 ; } ]
var: cur (cur) = form -> cur_page -> questions
var: question_t * cur (cur) = form -> cur_page -> questions
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur != NULL
=> ['cur', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cur']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
var: cur (cur) = cur -> next
var: question_t * cur (cur) = cur -> next
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 = cur -> title'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 = arg'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv16 = cur -> title'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = const char * 
var: tlv6 (tlv6) = cgc_strlen ( tlv16 )
var: cgc_size_t tlv6 (tlv6) = cgc_strlen ( tlv16 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; }
Assigns = [('cgc_size_t', 'tlv6', '', 'cgc_strlen ( tlv16 )')]
Compares = []
var: tlv2 (tlv2) = cgc_strncmp ( tlv8 , tlv7 , tlv6 )
var: int tlv2 (tlv2) = cgc_strncmp ( tlv8 , tlv7 , tlv6 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } ]
Assigns = [('int', 'tlv2', '', 'cgc_strncmp ( tlv8 , tlv7 , tlv6 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
=> ['tlv2', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [2.2]  int : tlv2
Resolved type: [2.3]  int : tlv2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { break ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv2 == 0 ) { break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { break ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv2 == 0 ) { break ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur == NULL
=> ['cur', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cur']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ cur == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = cgc_size_t 
var: tlv4 (tlv4) = LINE_SIZE
var: cgc_size_t tlv4 (tlv4) = LINE_SIZE
var: input_buf (input_buf) = cgc_malloc ( tlv4 )
var: char * input_buf (input_buf) = cgc_malloc ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }
Assigns = [('cgc_size_t', 'tlv4', '', 'LINE_SIZE'), ('char *', 'input_buf', '', 'cgc_malloc ( tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => input_buf == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => input_buf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => input_buf == NULL
=> ['input_buf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : input_buf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['input_buf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['input_buf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['input_buf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['input_buf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['input_buf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['input_buf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['input_buf']
FOUND IT! [2.2]  char * : input_buf
Resolved type: [2.3]  char * : input_buf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ input_buf == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( input_buf == NULL ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_prompt_q'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( cur )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = char * 
var: tlv5 (tlv5) = input_buf
var: char * tlv5 (tlv5) = input_buf
var: tlv1 (tlv1) = cgc_read_line ( tlv5 )
var: int tlv1 (tlv1) = cgc_read_line ( tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }
Assigns = [('char *', 'tlv5', '', 'input_buf'), ('int', 'tlv1', '', 'cgc_read_line ( tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1 < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => tlv1
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => tlv1 < 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : tlv1
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [1.2]  int : tlv1
Resolved type: [1.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 < 0 ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cgc_strlen ( input_buf ) == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cgc_strlen ( input_buf )
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cgc_strlen ( input_buf ) == 0
=> ['cgc_strlen ( input_buf )', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cgc_strlen ( input_buf )
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cgc_strlen ( input_buf )']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cgc_strlen ( input_buf )']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cgc_strlen ( input_buf )']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cgc_strlen ( input_buf )']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cgc_strlen ( input_buf )']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cgc_strlen ( input_buf )']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ArgumentExpressionListContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cgc_strlen', '(', 'input_buf', ')']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
Resolved type: [2.3]  UNDEF : 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => input_buf != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => input_buf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => input_buf != NULL
=> ['input_buf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : input_buf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['input_buf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['input_buf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['input_buf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['input_buf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['input_buf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['input_buf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['input_buf']
FOUND IT! [2.2]  char * : input_buf
Resolved type: [2.3]  char * : input_buf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ input_buf != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( input_buf )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_free ( input_buf ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( input_buf != NULL ) { cgc_free ( input_buf ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_free ( input_buf ) ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur -> answer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer != NULL
=> ['cur -> answer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur -> answer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur -> answer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur -> answer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur -> answer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur -> answer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur -> answer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur -> answer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cur', '->', 'answer']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ cur -> answer != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = void * 
var: tlv12 (tlv12) = cur -> answer
var: void * tlv12 (tlv12) = cur -> answer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv12 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; }
Assigns = [('void *', 'tlv12', '', 'cur -> answer')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } ]
var: cur -> answer (cur -> answer) = NULL
var: UNDEF cur -> answer (cur -> answer) = NULL
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } ]
Assigns = [('UNDEF', 'cur -> answer', '', 'NULL')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ! cur -> validator ( input_buf ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => input_buf != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => input_buf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => input_buf != NULL
=> ['input_buf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : input_buf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['input_buf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['input_buf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['input_buf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['input_buf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['input_buf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['input_buf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['input_buf']
FOUND IT! [2.2]  char * : input_buf
Resolved type: [2.3]  char * : input_buf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ input_buf != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( input_buf )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_free ( input_buf ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( input_buf != NULL ) { cgc_free ( input_buf ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_free ( input_buf ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur -> answer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur -> answer == NULL
=> ['cur -> answer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur -> answer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur -> answer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur -> answer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur -> answer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur -> answer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur -> answer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur -> answer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cur', '->', 'answer']
FOUND IT! [2.2]  question_t * : cur
Resolved type: [2.3]  question_t * : cur
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ cur -> answer == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: cur -> answer (cur -> answer) = input_buf
var: UNDEF cur -> answer (cur -> answer) = input_buf
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cur -> answer = input_buf ; }
Assigns = [('UNDEF', 'cur -> answer', '', 'input_buf')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ cur -> answer == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cur -> answer = input_buf ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv11 = cur -> answer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv10 = input_buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv17 = cur -> answer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = const char * 
var: tlv9 (tlv9) = cgc_strlen ( tlv17 )
var: cgc_size_t tlv9 (tlv9) = cgc_strlen ( tlv17 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; }
Assigns = [('cgc_size_t', 'tlv9', '', 'cgc_strlen ( tlv17 )')]
Compares = []
var: tlv3 (tlv3) = cgc_strncmp ( tlv11 , tlv10 , tlv9 )
var: int tlv3 (tlv3) = cgc_strncmp ( tlv11 , tlv10 , tlv9 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } ]
Assigns = [('int', 'tlv3', '', 'cgc_strncmp ( tlv11 , tlv10 , tlv9 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv3
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 == 0
=> ['tlv3', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv3
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv3']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv3']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv3']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv3']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv3']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv3']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv3']
FOUND IT! [2.2]  int : tlv3
Resolved type: [2.3]  int : tlv3
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv3 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = char * 
var: tlv14 (tlv14) = cur -> answer
var: char * tlv14 (tlv14) = cur -> answer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv13 = input_buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; }
Assigns = [('char *', 'tlv14', '', 'cur -> answer')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( input_buf )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv3 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = void * 
var: tlv15 (tlv15) = cur -> answer
var: void * tlv15 (tlv15) = cur -> answer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv15 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; }
Assigns = [('void *', 'tlv15', '', 'cur -> answer')]
Compares = []
var: cur -> answer (cur -> answer) = input_buf
var: UNDEF cur -> answer (cur -> answer) = input_buf
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } ]
Assigns = [('UNDEF', 'cur -> answer', '', 'input_buf')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cur -> answer = input_buf ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { question_t * cur ; char * input_buf ; if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } if ( arg == NULL ) { return 1 ; } cur = form -> cur_page -> questions ; for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } if ( input_buf == NULL ) { return - 1 ; } cgc_prompt_q ( cur ) ; int tlv1 ; { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } if ( tlv1 < 0 ) { return - 1 ; } if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } return 1 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( arg == NULL ) { return 1 ; } ]
 2 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } ]
 5 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( input_buf == NULL ) { return - 1 ; } ]
 6 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } ]
 7 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 < 0 ) { return - 1 ; } ]
 8 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } ]
 9 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ]
 10 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } ]
Assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_handle_update ( form_t * form , char * arg ) { question_t * cur ; char * input_buf ; if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } if ( arg == NULL ) { return 1 ; } cur = form -> cur_page -> questions ; for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } if ( input_buf == NULL ) { return - 1 ; } cgc_prompt_q ( cur ) ; int tlv1 ; { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } if ( tlv1 < 0 ) { return - 1 ; } if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { question_t * cur ; char * input_buf ; if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } if ( arg == NULL ) { return 1 ; } cur = form -> cur_page -> questions ; for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } if ( input_buf == NULL ) { return - 1 ; } cgc_prompt_q ( cur ) ; int tlv1 ; { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } if ( tlv1 < 0 ) { return - 1 ; } if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } return 1 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_print_prompt ( form_t * form , int with_title , int done )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = int, var = with_title [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['with_title']
[enterParameterDeclaration] int : with_title
sym_dict [with_title] = int 
ParameterDeclaration : type = int, var = done [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['done']
[enterParameterDeclaration] int : done
sym_dict [done] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> title == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_page -> title
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_page -> title == NULL
=> ['form -> cur_page -> title', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_page -> title
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_page -> title']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_page -> title']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_page -> title']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_page -> title']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_page -> title']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_page -> title']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_page', '->', 'title']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> title == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s" , form -> ending ) ; return ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s" , form -> ending ) ; return ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ with_title ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_print_title'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( form )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_print_title ( form ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( with_title ) { cgc_print_title ( form ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_print_title ( form ) ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> completed ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_print_page'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( form )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'question_t * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = question_t * 
var: tlv1 (tlv1) = form -> cur_question
var: question_t * tlv1 (tlv1) = form -> cur_question
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_prompt_q'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv1 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; }
Assigns = [('question_t *', 'tlv1', '', 'form -> cur_question')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } if ( with_title ) { cgc_print_title ( form ) ; } if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( with_title ) { cgc_print_title ( form ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_print_prompt ( form_t * form , int with_title , int done ) { if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } if ( with_title ) { cgc_print_title ( form ) ; } if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } if ( with_title ) { cgc_print_title ( form ) ; } if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_handle_line ( form_t * form , char * buf )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'static int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = static int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'form_t * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = form_t * 
var: tlv4 (tlv4) = form
var: form_t * tlv4 (tlv4) = form
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = char * 
var: tlv3 (tlv3) = buf
var: char * tlv3 (tlv3) = buf
var: tlv1 (tlv1) = cgc_is_cmd ( tlv4 , tlv3 )
var: static int tlv1 (tlv1) = cgc_is_cmd ( tlv4 , tlv3 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; }
Assigns = [('form_t *', 'tlv4', '', 'form'), ('char *', 'tlv3', '', 'buf'), ('static int', 'tlv1', '', 'cgc_is_cmd ( tlv4 , tlv3 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return cgc_handle_cmd ( form , buf ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return cgc_handle_cmd ( form , buf ) ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => form -> cur_question
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => form -> cur_question == NULL
=> ['form -> cur_question', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : form -> cur_question
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['form -> cur_question']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['form -> cur_question']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['form -> cur_question']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['form -> cur_question']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['form -> cur_question']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['form -> cur_question']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['form', '->', 'cur_question']
FOUND IT! [2.2]  form_t * : form
Resolved type: [2.3]  form_t * : form
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ form -> cur_page -> completed || form -> cur_question == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 1 ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 = buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = const char * 
var: tlv2 (tlv2) = cgc_strlen ( tlv5 )
var: cgc_size_t tlv2 (tlv2) = cgc_strlen ( tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; }
Assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
=> ['tlv2', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [2.2]  cgc_size_t : tlv2
Resolved type: [2.3]  cgc_size_t : tlv2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ! form -> cur_question -> optional ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ! form -> cur_question -> optional ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( ! form -> cur_question -> optional ) { return 0 ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ! form -> cur_question -> optional ) { return 0 ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { if ( ! form -> cur_question -> optional ) { return 0 ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'form_t * tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = form_t * 
var: tlv8 (tlv8) = form
var: form_t * tlv8 (tlv8) = form
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = buf
var: char * tlv7 (tlv7) = buf
var: ret (ret) = cgc_handle_answer ( tlv8 , tlv7 )
var: int ret (ret) = cgc_handle_answer ( tlv8 , tlv7 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; }
Assigns = [('form_t *', 'tlv8', '', 'form'), ('char *', 'tlv7', '', 'buf'), ('int', 'ret', '', 'cgc_handle_answer ( tlv8 , tlv7 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => ret < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => ret
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => ret < 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : ret
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [1.2]  int : ret
Resolved type: [1.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret < 0 ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret < 0 ) { return - 1 ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { return 0 ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( ! form -> cur_question -> optional ) { return 0 ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'form_t * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = form_t * 
var: tlv6 (tlv6) = form
var: form_t * tlv6 (tlv6) = form
var: ret (ret) = cgc_next_question ( tlv6 )
var: int ret (ret) = cgc_next_question ( tlv6 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }
Assigns = [('form_t *', 'tlv6', '', 'form'), ('int', 'ret', '', 'cgc_next_question ( tlv6 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => ret < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => ret
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => ret < 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : ret
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [1.2]  int : ret
Resolved type: [1.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return - 1 ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret < 0 ) { return - 1 ; } else { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; static int tlv1 ; { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } cgc_size_t tlv2 ; { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } if ( ret < 0 ) { return - 1 ; } else { return 0 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } ]
 6 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret < 0 ) { return - 1 ; } else { return 0 ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_handle_line ( form_t * form , char * buf ) { int ret ; static int tlv1 ; { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } cgc_size_t tlv2 ; { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } if ( ret < 0 ) { return - 1 ; } else { return 0 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; static int tlv1 ; { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } cgc_size_t tlv2 ; { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } if ( ret < 0 ) { return - 1 ; } else { return 0 ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_print_greeting ( form_t * form )')]
ParameterDeclaration : type = form_t *, var = form [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['form']
[enterParameterDeclaration] form_t * : form
sym_dict [form] = form_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "%s" , form -> greeting ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_print_greeting ( form_t * form ) { cgc_printf ( "%s" , form -> greeting ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "%s" , form -> greeting ) ; } ]
compound scope 0 : { int i ; char * p ; p = buf ; char cmd_buf [ MAX_CMD_SIZE ] ; while ( * p == '*' && p - buf < 2 ) { p ++ ; } for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } return - 1 ; }
compound scope 1 : { p ++ ; }
compound scope 2 : { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } }
compound scope 3 : { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 4 : { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; }
compound scope 5 : { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; }
compound scope 6 : { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; }
compound scope 7 : { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; }
compound scope 8 : { return i ; }
len(compound_scope) : 9
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; char * p ; p = buf ; char cmd_buf [ MAX_CMD_SIZE ] ; while ( * p == '*' && p - buf < 2 ) { p ++ ; } for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; char * p ; p = buf ; char cmd_buf [ MAX_CMD_SIZE ] ; while ( * p == '*' && p - buf < 2 ) { p ++ ; } for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } return - 1 ; } ] 
p_decls = [('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('char *', 'p', '', 'buf')]
compares = []
===> context { int i ; char * p ; p = buf ; char cmd_buf [ MAX_CMD_SIZE ] ; while ( * p == '*' && p - buf < 2 ) { p ++ ; } for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } return - 1 ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: i
1 : |  decl_scope  | type: char *, var: p
2 : |  decl_scope  | type: char *, var: cmd_buf
3 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: char *, value: buf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { p ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { p ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf')]
compares = ['', '', '', '']
===> context { p ++ ; }
ignore sibs: ["for ( i = 0 ; i < NUM_CMDS ; i ++ ) { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } }", 'return - 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: char *, var: p
4 : |  decl_scope  | type: char *, var: cmd_buf
5 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
0 : | assign_scope | type: char *, value: buf
0 : |compare_scopes| type: char, value: * p
1 : |compare_scopes| type: char, value: '*'
2 : |compare_scopes| type: char *, value: p - buf
3 : |compare_scopes| type: char *, value: 2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } } ] 
p_decls = [('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('int', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf')]
compares = []
decls = [('int', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } int tlv1 ; { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { return i ; } }
ignore sibs: ['return - 1 ;', '}']
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: char *, var: p
5 : |  decl_scope  | type: char *, var: cmd_buf
6 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_CMDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('void *', 'tlv4', '', 'cmd_buf'), ('void *', 'tlv3', '', 'p')]
compares = []
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('void *', 'tlv4', '', 'cmd_buf'), ('void *', 'tlv3', '', 'p'), ('char *', 'p', '', 'buf')]
compares = []
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('void *', 'tlv4', '', 'cmd_buf'), ('void *', 'tlv3', '', 'p'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('void *', 'tlv4', '', 'cmd_buf'), ('void *', 'tlv3', '', 'p'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { void * tlv4 ; tlv4 = cmd_buf ; void * tlv3 ; tlv3 = p ; cgc_size_t tlv2 ; { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ["{ const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\\0' ; }", 'int tlv1 ;', '{ const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( tlv1 == 0 ) { return i ; }', '}', 'return - 1 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: form_t *, var: form
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: char *, var: p
7 : |  decl_scope  | type: char *, var: cmd_buf
8 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
0 : | assign_scope | type: void *, value: cmd_buf
1 : | assign_scope | type: void *, value: p
2 : | assign_scope | type: char *, value: buf
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_CMDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; } ] 
p_decls = [('const char *', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv9 )')]
compares = []
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv9 )'), ('char *', 'p', '', 'buf')]
compares = []
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv9 )'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv9 )'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None), ('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv9 )'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0'), ('void *', 'tlv4', '', 'cmd_buf'), ('void *', 'tlv3', '', 'p')]
compares = ['', '']
===> context { const char * tlv9 = cmd_lbls [ i ] ; tlv2 = cgc_strlen ( tlv9 ) ; }
ignore sibs: ['cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ;', '}', "{ const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\\0' ; }", 'int tlv1 ;', '{ const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( tlv1 == 0 ) { return i ; }', '}', 'return - 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv9
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: char *, var: p
5 : |  decl_scope  | type: char *, var: cmd_buf
6 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
7 : |  decl_scope  | type: void *, var: tlv4
8 : |  decl_scope  | type: void *, var: tlv3
9 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv9 )
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: void *, value: cmd_buf
4 : | assign_scope | type: void *, value: p
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_CMDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; } ] 
p_decls = [('const char *', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv8', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('UNDEF', 'cmd_buf ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'")]
compares = []
decls = [('const char *', 'tlv8', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('UNDEF', 'cmd_buf ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'"), ('char *', 'p', '', 'buf')]
compares = []
decls = [('const char *', 'tlv8', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('UNDEF', 'cmd_buf ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'"), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv8', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('UNDEF', 'cmd_buf ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'"), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { const char * tlv8 = cmd_lbls [ i ] ; cmd_buf [ cgc_strlen ( tlv8 ) ] = '\0' ; }
ignore sibs: ['int tlv1 ;', '{ const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( tlv1 == 0 ) { return i ; }', '}', 'return - 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv8
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: char *, var: p
5 : |  decl_scope  | type: char *, var: cmd_buf
6 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
0 : | assign_scope | type: UNDEF, value: '\0'
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_CMDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf')]
compares = []
decls = [('const char *', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None), ('int', 'tlv1', None)]
assigns = [('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { const char * tlv7 = cmd_buf ; const char * tlv6 = cmd_lbls [ i ] ; cgc_size_t tlv5 ; { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { return i ; }', '}', 'return - 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv7
1 : |  decl_scope  | type: const char *, var: tlv6
2 : |  decl_scope  | type: cgc_size_t, var: tlv5
3 : |  decl_scope  | type: form_t *, var: form
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: char *, var: p
7 : |  decl_scope  | type: char *, var: cmd_buf
8 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
9 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_CMDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; } ] 
p_decls = [('const char *', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv10', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv10 )')]
compares = []
decls = [('const char *', 'tlv10', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv10 )'), ('char *', 'p', '', 'buf')]
compares = []
decls = [('const char *', 'tlv10', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv10 )'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv10', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv10 )'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv10', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None), ('int', 'tlv1', None), ('const char *', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv10 )'), ('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { const char * tlv10 = cmd_lbls [ i ] ; tlv5 = cgc_strlen ( tlv10 ) ; }
ignore sibs: ['tlv1 = cgc_strncasecmp ( tlv7 , tlv6 , tlv5 ) ;', '}', 'if ( tlv1 == 0 ) { return i ; }', '}', 'return - 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv10
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: char *, var: p
5 : |  decl_scope  | type: char *, var: cmd_buf
6 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: const char *, var: tlv7
9 : |  decl_scope  | type: const char *, var: tlv6
10 : |  decl_scope  | type: cgc_size_t, var: tlv5
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv10 )
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_CMDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return i ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return i ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)]
assigns = [('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None), ('int', 'tlv1', None)]
assigns = [('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'i', None), ('char *', 'p', None), ('char *', 'cmd_buf', ' [ MAX_CMD_SIZE ]'), ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None), ('int', 'tlv1', None)]
assigns = [('char *', 'p', '', 'buf'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { return i ; }
ignore sibs: ['}', 'return - 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: char *, var: p
4 : |  decl_scope  | type: char *, var: cmd_buf
5 : |  decl_scope  | type: char, var: cmd_buf [ MAX_CMD_SIZE ]
6 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_CMDS
2 : |compare_scopes| type: int, value: tlv1
3 : |compare_scopes| type: int, value: 0
=======END=======
compound scope 0 : { int tlv1 ; { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 ) { return 0 ; } return cgc_handler_index ( form , buf ) >= 0 ; }
compound scope 1 : { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 2 : { return 0 ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 ) { return 0 ; } return cgc_handler_index ( form , buf ) >= 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 ) { return 0 ; } return cgc_handler_index ( form , buf ) >= 0 ; } ] 
p_decls = [('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = ['']
===> context { int tlv1 ; { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 ) { return 0 ; } return cgc_handler_index ( form , buf ) >= 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('const char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('const char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('cgc_size_t', 'tlv2', '', '2')]
compares = []
decls = [('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('const char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv2', '', '2')]
compares = []
===> context { const char tlv4 [ ] = "**" ; const char * tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = 2 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( tlv1 ) { return 0 ; }', 'return cgc_handler_index ( form , buf ) >= 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv4
1 : |  decl_scope  | type: const char, var: tlv4 [ ]
2 : |  decl_scope  | type: const char *, var: tlv3
3 : |  decl_scope  | type: cgc_size_t, var: tlv2
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: 2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'tlv1', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'tlv1', None)]
assigns = []
compares = []
===> context { return 0 ; }
ignore sibs: ['return cgc_handler_index ( form , buf ) >= 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: tlv1
=======END=======
compound scope 0 : { question_t * cur ; cur = form -> cur_page -> questions ; int completed ; completed = 1 ; while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } return completed && form -> cur_question == NULL ; }
compound scope 1 : { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } }
compound scope 2 : { completed = 0 ; break ; }
compound scope 3 : { cur = cur -> next ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * cur ; cur = form -> cur_page -> questions ; int completed ; completed = 1 ; while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } return completed && form -> cur_question == NULL ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * cur ; cur = form -> cur_page -> questions ; int completed ; completed = 1 ; while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } return completed && form -> cur_question == NULL ; } ] 
p_decls = [('question_t *', 'cur', None), ('int', 'completed', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('question_t *', 'cur', None), ('int', 'completed', None), ('form_t *', 'form', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = ['', '']
===> context { question_t * cur ; cur = form -> cur_page -> questions ; int completed ; completed = 1 ; while ( cur != NULL ) { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } return completed && form -> cur_question == NULL ; }
ignore sibs: []
0 : |  decl_scope  | type: question_t *, var: cur
1 : |  decl_scope  | type: int, var: completed
2 : |  decl_scope  | type: form_t *, var: form
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: int, value: 1
0 : |compare_scopes| type: form_t *, value: form -> cur_question
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = ['', '']
===> context { if ( ! cur -> optional && cur -> answer == NULL ) { completed = 0 ; break ; } else { cur = cur -> next ; } }
ignore sibs: ['return completed && form -> cur_question == NULL ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: completed
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: int, value: 1
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { completed = 0 ; break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { completed = 0 ; break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = [('int', 'completed', '', '0')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('int', 'completed', '', '0'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('int', 'completed', '', '0'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('int', 'completed', '', '0'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('int', 'completed', '', '0'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = ['', '', '', '']
===> context { completed = 0 ; break ; }
ignore sibs: ['else', '{ cur = cur -> next ; }', '}', 'return completed && form -> cur_question == NULL ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: completed
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
2 : | assign_scope | type: int, value: 1
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
2 : |compare_scopes| type: question_t *, value: cur -> answer
3 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cur = cur -> next ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cur = cur -> next ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = [('question_t *', 'cur', '', 'cur -> next')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('question_t *', 'cur', '', 'cur -> next'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('question_t *', 'cur', '', 'cur -> next'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'completed', None)]
assigns = [('question_t *', 'cur', '', 'cur -> next'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('int', 'completed', '', '1')]
compares = ['', '']
===> context { cur = cur -> next ; }
ignore sibs: ['}', 'return completed && form -> cur_question == NULL ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: completed
0 : | assign_scope | type: question_t *, value: cur -> next
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
2 : | assign_scope | type: int, value: 1
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
compound scope 0 : { int tlv1 ; { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } }
compound scope 1 : { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 2 : { cgc_printf ( "\nFinal Questions\n" ) ; }
compound scope 3 : { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } } ] 
p_decls = [('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('form_t *', 'form', None)]
assigns = []
compares = []
===> context { int tlv1 ; { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: form_t *, var: form
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('const char *', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None)]
assigns = [('cgc_size_t', 'tlv2', '', '3')]
compares = []
decls = [('const char *', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv2', '', '3')]
compares = []
===> context { const char * tlv4 = form -> cur_page -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { cgc_printf ( "\\nFinal Questions\\n" ) ; } else { cgc_printf ( "\\n%s Form\\n" , form -> cur_page -> title ) ; }', '}']
0 : |  decl_scope  | type: const char *, var: tlv4
1 : |  decl_scope  | type: const char *, var: tlv3
2 : |  decl_scope  | type: const char, var: tlv3 [ ]
3 : |  decl_scope  | type: cgc_size_t, var: tlv2
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: 3
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\nFinal Questions\n" ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\nFinal Questions\n" ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( "\nFinal Questions\n" ) ; }
ignore sibs: ['else', '{ cgc_printf ( "\\n%s Form\\n" , form -> cur_page -> title ) ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: tlv1
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = []
compares = []
===> context { cgc_printf ( "\n%s Form\n" , form -> cur_page -> title ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: tlv1
=======END=======
compound scope 0 : { char * arg ; { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } int ret ; if ( arg == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } char * cmd ; { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } int i ; { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } if ( i < 0 ) { ret = i ; goto out ; } ret = form -> handlers [ i ] ( form , arg ) ; out : if ( cmd != NULL ) { cgc_free ( cmd ) ; } return ret ; }
compound scope 1 : { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; }
compound scope 2 : { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; }
compound scope 3 : { return - 1 ; }
compound scope 4 : { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; }
compound scope 5 : { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; }
compound scope 6 : { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }
compound scope 7 : { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }
compound scope 8 : { ret = i ; goto out ; }
compound scope 9 : { cgc_free ( cmd ) ; }
len(compound_scope) : 10
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * arg ; { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } int ret ; if ( arg == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } char * cmd ; { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } int i ; { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } if ( i < 0 ) { ret = i ; goto out ; } ret = form -> handlers [ i ] ( form , arg ) ; out : if ( cmd != NULL ) { cgc_free ( cmd ) ; } return ret ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * arg ; { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } int ret ; if ( arg == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } char * cmd ; { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } int i ; { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } if ( i < 0 ) { ret = i ; goto out ; } ret = form -> handlers [ i ] ( form , arg ) ; out : if ( cmd != NULL ) { cgc_free ( cmd ) ; } return ret ; } ] 
p_decls = [('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None), ('int', 'i', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None), ('int', 'i', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('int', 'ret', '', 'form -> handlers [ i ] ( form , arg )')]
compares = []
===> context { char * arg ; { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } int ret ; if ( arg == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } char * cmd ; { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } int i ; { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } if ( i < 0 ) { ret = i ; goto out ; } ret = form -> handlers [ i ] ( form , arg ) ; out : if ( cmd != NULL ) { cgc_free ( cmd ) ; } return ret ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: arg
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: char *, var: cmd
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: int, value: form -> handlers [ i ] ( form , arg )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('cgc_size_t', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None)]
assigns = []
compares = []
===> context { cgc_size_t tlv3 ; { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } arg = cgc_malloc ( tlv3 ) ; }
ignore sibs: ['int ret ;', 'if ( arg == NULL ) { return - 1 ; }', '{ char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; }', "{ const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\\0' ; }", 'char * cmd ;', '{ char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }', 'int i ;', '{ form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }', 'if ( i < 0 ) { ret = i ; goto out ; }', 'ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv3
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char *, var: arg
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; } ] 
p_decls = [('const char *', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv9 ) + 1')]
compares = []
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv9 ) + 1')]
compares = []
decls = [('const char *', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv9 ) + 1')]
compares = []
===> context { const char * tlv9 = buf ; tlv3 = cgc_strlen ( tlv9 ) + 1 ; }
ignore sibs: ['arg = cgc_malloc ( tlv3 ) ;', '}', 'int ret ;', 'if ( arg == NULL ) { return - 1 ; }', '{ char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; }', "{ const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\\0' ; }", 'char * cmd ;', '{ char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }', 'int i ;', '{ form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }', 'if ( i < 0 ) { ret = i ; goto out ; }', 'ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv9
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char *, var: arg
4 : |  decl_scope  | type: cgc_size_t, var: tlv3
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv9 ) + 1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['{ char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; }', "{ const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\\0' ; }", 'char * cmd ;', '{ char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }', 'int i ;', '{ form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }', 'if ( i < 0 ) { ret = i ; goto out ; }', 'ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: int, var: ret
0 : |compare_scopes| type: char *, value: arg
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; } ] 
p_decls = [('char *', 'tlv2', None), ('const char *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv2', None), ('const char *', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('char *', 'tlv2', '', 'arg')]
compares = []
decls = [('char *', 'tlv2', None), ('const char *', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv2', '', 'arg')]
compares = []
===> context { char * tlv2 ; tlv2 = arg ; const char * tlv1 = buf ; cgc_strcpy ( tlv2 , tlv1 ) ; }
ignore sibs: ["{ const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\\0' ; }", 'char * cmd ;', '{ char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }', 'int i ;', '{ form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }', 'if ( i < 0 ) { ret = i ; goto out ; }', 'ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: tlv2
1 : |  decl_scope  | type: const char *, var: tlv1
2 : |  decl_scope  | type: form_t *, var: form
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char *, var: arg
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: arg
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; } ] 
p_decls = [('const char *', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv8', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('UNDEF', 'arg ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'")]
compares = []
decls = [('const char *', 'tlv8', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = [('UNDEF', 'arg ', '[ cgc_strlen ( tlv8 ) ]', "'\\0'")]
compares = []
===> context { const char * tlv8 = buf ; arg [ cgc_strlen ( tlv8 ) ] = '\0' ; }
ignore sibs: ['char * cmd ;', '{ char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }', 'int i ;', '{ form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }', 'if ( i < 0 ) { ret = i ; goto out ; }', 'ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv8
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char *, var: arg
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; } ] 
p_decls = [('char * *', 'tlv5', None), ('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv5', None), ('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('char * *', 'tlv5', '', '& arg')]
compares = []
decls = [('char * *', 'tlv5', None), ('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None)]
assigns = [('char * *', 'tlv5', '', '& arg')]
compares = []
===> context { char * * tlv5 ; tlv5 = & arg ; const char tlv4 [ ] = " " ; cmd = cgc_strsep ( tlv5 , tlv4 ) ; }
ignore sibs: ['int i ;', '{ form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }', 'if ( i < 0 ) { ret = i ; goto out ; }', 'ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv5
1 : |  decl_scope  | type: const char *, var: tlv4
2 : |  decl_scope  | type: const char, var: tlv4 [ ]
3 : |  decl_scope  | type: form_t *, var: form
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char *, var: arg
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: char *, var: cmd
0 : | assign_scope | type: char * *, value: & arg
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; } ] 
p_decls = [('form_t *', 'tlv7', None), ('char *', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'tlv7', None), ('char *', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('form_t *', 'tlv7', '', 'form'), ('char *', 'tlv6', '', 'cmd')]
compares = []
decls = [('form_t *', 'tlv7', None), ('char *', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None), ('int', 'i', None)]
assigns = [('form_t *', 'tlv7', '', 'form'), ('char *', 'tlv6', '', 'cmd')]
compares = []
===> context { form_t * tlv7 ; tlv7 = form ; char * tlv6 ; tlv6 = cmd ; i = cgc_handler_index ( tlv7 , tlv6 ) ; }
ignore sibs: ['if ( i < 0 ) { ret = i ; goto out ; }', 'ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: form_t *, var: tlv7
1 : |  decl_scope  | type: char *, var: tlv6
2 : |  decl_scope  | type: form_t *, var: form
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char *, var: arg
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: char *, var: cmd
7 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: form_t *, value: form
1 : | assign_scope | type: char *, value: cmd
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = i ; goto out ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = i ; goto out ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('int', 'ret', '', 'i')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None), ('int', 'i', None)]
assigns = [('int', 'ret', '', 'i')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None), ('int', 'i', None)]
assigns = [('int', 'ret', '', 'i')]
compares = ['', '']
===> context { ret = i ; goto out ; }
ignore sibs: ['ret = form -> handlers [ i ] ( form , arg ) ;', 'out : if ( cmd != NULL ) { cgc_free ( cmd ) ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char *, var: cmd
5 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: i
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( cmd ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( cmd ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None), ('int', 'i', None)]
assigns = [('int', 'ret', '', 'form -> handlers [ i ] ( form , arg )')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('char *', 'arg', None), ('int', 'ret', None), ('char *', 'cmd', None), ('int', 'i', None)]
assigns = [('int', 'ret', '', 'form -> handlers [ i ] ( form , arg )')]
compares = ['', '']
===> context { cgc_free ( cmd ) ; }
ignore sibs: ['return ret ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char *, var: cmd
5 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: form -> handlers [ i ] ( form , arg )
0 : |compare_scopes| type: char *, value: cmd
1 : |compare_scopes| type: char *, value: NULL
=======END=======
compound scope 0 : { if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } if ( form -> cur_question -> answer == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } return 0 ; }
compound scope 1 : { return 1 ; }
compound scope 2 : { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } }
compound scope 3 : { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; }
compound scope 4 : { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; }
compound scope 5 : { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; }
compound scope 6 : { return - 1 ; }
compound scope 7 : { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }
len(compound_scope) : 8
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } if ( form -> cur_question -> answer == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } if ( form -> cur_question -> answer == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
===> context { if ( ! form -> cur_question -> validator ( input ) ) { return 1 ; } if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } if ( form -> cur_question -> answer == NULL ) { return - 1 ; } { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: input
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
===> context { return 1 ; }
ignore sibs: ['if ( form -> cur_question -> answer != NULL ) { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } }', '{ cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; }', 'if ( form -> cur_question -> answer == NULL ) { return - 1 ; }', '{ char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: input
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = ['', '']
===> context { { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } }
ignore sibs: ['{ cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; }', 'if ( form -> cur_question -> answer == NULL ) { return - 1 ; }', '{ char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: input
0 : |compare_scopes| type: form_t *, value: form -> cur_question -> answer
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; } ] 
p_decls = [('void *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv4', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('void *', 'tlv4', '', 'form -> cur_question -> answer')]
compares = []
decls = [('void *', 'tlv4', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('void *', 'tlv4', '', 'form -> cur_question -> answer')]
compares = []
decls = [('void *', 'tlv4', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('void *', 'tlv4', '', 'form -> cur_question -> answer')]
compares = ['', '']
decls = [('void *', 'tlv4', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('void *', 'tlv4', '', 'form -> cur_question -> answer')]
compares = ['', '']
===> context { void * tlv4 ; tlv4 = form -> cur_question -> answer ; cgc_free ( tlv4 ) ; }
ignore sibs: ['}', '{ cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; }', 'if ( form -> cur_question -> answer == NULL ) { return - 1 ; }', '{ char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv4
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: input
0 : | assign_scope | type: void *, value: form -> cur_question -> answer
0 : |compare_scopes| type: form_t *, value: form -> cur_question -> answer
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
decls = [('cgc_size_t', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
===> context { cgc_size_t tlv3 ; { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } form -> cur_question -> answer = cgc_malloc ( tlv3 ) ; }
ignore sibs: ['if ( form -> cur_question -> answer == NULL ) { return - 1 ; }', '{ char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv3
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: input
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; } ] 
p_decls = [('const char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv5 ) + 1')]
compares = []
decls = [('const char *', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv5 ) + 1')]
compares = []
decls = [('const char *', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'input', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv5 ) + 1')]
compares = []
===> context { const char * tlv5 = input ; tlv3 = cgc_strlen ( tlv5 ) + 1 ; }
ignore sibs: ['form -> cur_question -> answer = cgc_malloc ( tlv3 ) ;', '}', 'if ( form -> cur_question -> answer == NULL ) { return - 1 ; }', '{ char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv5
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: input
3 : |  decl_scope  | type: cgc_size_t, var: tlv3
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv5 ) + 1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'input', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['{ char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: input
0 : |compare_scopes| type: form_t *, value: form -> cur_question -> answer
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; } ] 
p_decls = [('char *', 'tlv2', None), ('const char *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv2', None), ('const char *', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('char *', 'tlv2', '', 'form -> cur_question -> answer')]
compares = []
decls = [('char *', 'tlv2', None), ('const char *', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'input', None)]
assigns = [('char *', 'tlv2', '', 'form -> cur_question -> answer')]
compares = []
===> context { char * tlv2 ; tlv2 = form -> cur_question -> answer ; const char * tlv1 = input ; cgc_strcpy ( tlv2 , tlv1 ) ; }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv2
1 : |  decl_scope  | type: const char *, var: tlv1
2 : |  decl_scope  | type: form_t *, var: form
3 : |  decl_scope  | type: char *, var: input
0 : | assign_scope | type: char *, value: form -> cur_question -> answer
=======END=======
compound scope 0 : { if ( form -> cur_question == NULL ) { return - 1 ; } if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } return 0 ; }
compound scope 1 : { return - 1 ; }
compound scope 2 : { form -> cur_page -> completed = 1 ; }
compound scope 3 : { form -> cur_question = form -> cur_question -> next ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_question == NULL ) { return - 1 ; } if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_question == NULL ) { return - 1 ; } if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
===> context { if ( form -> cur_question == NULL ) { return - 1 ; } if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['if ( form -> cur_question -> next == NULL ) { form -> cur_page -> completed = 1 ; } else { form -> cur_question = form -> cur_question -> next ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
0 : |compare_scopes| type: form_t *, value: form -> cur_question
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form -> cur_page -> completed = 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form -> cur_page -> completed = 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = [('UNDEF', 'form -> cur_page -> completed', '', '1')]
compares = []
decls = [('form_t *', 'form', None)]
assigns = [('UNDEF', 'form -> cur_page -> completed', '', '1')]
compares = []
decls = [('form_t *', 'form', None)]
assigns = [('UNDEF', 'form -> cur_page -> completed', '', '1')]
compares = ['', '']
===> context { form -> cur_page -> completed = 1 ; }
ignore sibs: ['else', '{ form -> cur_question = form -> cur_question -> next ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
0 : | assign_scope | type: UNDEF, value: 1
0 : |compare_scopes| type: form_t *, value: form -> cur_question -> next
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form -> cur_question = form -> cur_question -> next ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form -> cur_question = form -> cur_question -> next ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = [('UNDEF', 'form -> cur_question', '', 'form -> cur_question -> next')]
compares = []
decls = [('form_t *', 'form', None)]
assigns = [('UNDEF', 'form -> cur_question', '', 'form -> cur_question -> next')]
compares = []
===> context { form -> cur_question = form -> cur_question -> next ; }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
0 : | assign_scope | type: UNDEF, value: form -> cur_question -> next
=======END=======
compound scope 0 : { question_t * cur ; cur = form -> cur_page -> questions ; int tlv1 ; { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } }
compound scope 1 : { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; }
compound scope 2 : { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; }
compound scope 3 : { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } }
compound scope 4 : { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; }
compound scope 5 : { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; }
compound scope 6 : { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } }
compound scope 7 : { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; }
compound scope 8 : { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; }
compound scope 9 : { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; }
compound scope 10 : { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } }
compound scope 11 : { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; }
compound scope 12 : { cgc_printf ( "%s=\n" , cur -> title ) ; }
len(compound_scope) : 13
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * cur ; cur = form -> cur_page -> questions ; int tlv1 ; { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * cur ; cur = form -> cur_page -> questions ; int tlv1 ; { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } } ] 
p_decls = [('question_t *', 'cur', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('question_t *', 'cur', None), ('int', 'tlv1', None), ('form_t *', 'form', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { question_t * cur ; cur = form -> cur_page -> questions ; int tlv1 ; { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } }
ignore sibs: []
0 : |  decl_scope  | type: question_t *, var: cur
1 : |  decl_scope  | type: int, var: tlv1
2 : |  decl_scope  | type: form_t *, var: form
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; } ] 
p_decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None), ('cgc_size_t', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None), ('cgc_size_t', 'tlv4', None), ('form_t *', 'form', None)]
assigns = [('cgc_size_t', 'tlv4', '', '3')]
compares = []
decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None), ('cgc_size_t', 'tlv4', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv4', '', '3'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { const char * tlv6 = form -> cur_page -> title ; const char tlv5 [ ] = "Edu" ; cgc_size_t tlv4 ; tlv4 = 3 ; tlv1 = cgc_strncmp ( tlv6 , tlv5 , tlv4 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { cgc_printf ( "\\n*********Highest %s:*********\\n" , form -> cur_page -> title ) ; } else { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\\n*********Most Recent Employer:*********\\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\\n*********Final Screening:*********\\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\\n*********%s:*********\\n" , form -> cur_page -> title ) ; } } }', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: const char *, var: tlv5
2 : |  decl_scope  | type: const char, var: tlv5 [ ]
3 : |  decl_scope  | type: cgc_size_t, var: tlv4
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: question_t *, var: cur
6 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: 3
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { cgc_printf ( "\n*********Highest %s:*********\n" , form -> cur_page -> title ) ; }
ignore sibs: ['else', '{ int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\\n*********Most Recent Employer:*********\\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\\n*********Final Screening:*********\\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\\n*********%s:*********\\n" , form -> cur_page -> title ) ; } } }', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } } ] 
p_decls = [('int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('int', 'tlv2', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { int tlv2 ; { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } if ( tlv2 == 0 ) { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } }
ignore sibs: ['for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; } ] 
p_decls = [('const char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('cgc_size_t', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('cgc_size_t', 'tlv7', None), ('form_t *', 'form', None)]
assigns = [('cgc_size_t', 'tlv7', '', '3')]
compares = []
decls = [('const char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('cgc_size_t', 'tlv7', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv7', '', '3'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('cgc_size_t', 'tlv7', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('cgc_size_t', 'tlv7', '', '3'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { const char * tlv9 = form -> cur_page -> title ; const char tlv8 [ ] = "Emp" ; cgc_size_t tlv7 ; tlv7 = 3 ; tlv2 = cgc_strncmp ( tlv9 , tlv8 , tlv7 ) ; }
ignore sibs: ['if ( tlv2 == 0 ) { cgc_printf ( "\\n*********Most Recent Employer:*********\\n" , form -> cur_page -> title ) ; } else { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\\n*********Final Screening:*********\\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\\n*********%s:*********\\n" , form -> cur_page -> title ) ; } }', '}', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: const char *, var: tlv9
1 : |  decl_scope  | type: const char *, var: tlv8
2 : |  decl_scope  | type: const char, var: tlv8 [ ]
3 : |  decl_scope  | type: cgc_size_t, var: tlv7
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: question_t *, var: cur
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: cgc_size_t, value: 3
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { cgc_printf ( "\n*********Most Recent Employer:*********\n" , form -> cur_page -> title ) ; }
ignore sibs: ['else', '{ int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\\n*********Final Screening:*********\\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\\n*********%s:*********\\n" , form -> cur_page -> title ) ; } }', '}', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: tlv1
3 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: int, value: tlv2
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } } ] 
p_decls = [('int', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None), ('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('int', 'tlv3', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('int', 'tlv3', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { int tlv3 ; { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } if ( tlv3 == 0 ) { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } }
ignore sibs: ['}', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; } ] 
p_decls = [('const char *', 'tlv12', None), ('const char *', 'tlv11', ' [ ]'), ('const char', 'tlv11 [ ]', None), ('cgc_size_t', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv12', None), ('const char *', 'tlv11', ' [ ]'), ('const char', 'tlv11 [ ]', None), ('cgc_size_t', 'tlv10', None), ('form_t *', 'form', None)]
assigns = [('cgc_size_t', 'tlv10', '', '3')]
compares = []
decls = [('const char *', 'tlv12', None), ('const char *', 'tlv11', ' [ ]'), ('const char', 'tlv11 [ ]', None), ('cgc_size_t', 'tlv10', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv10', '', '3'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv12', None), ('const char *', 'tlv11', ' [ ]'), ('const char', 'tlv11 [ ]', None), ('cgc_size_t', 'tlv10', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('cgc_size_t', 'tlv10', '', '3'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv12', None), ('const char *', 'tlv11', ' [ ]'), ('const char', 'tlv11 [ ]', None), ('cgc_size_t', 'tlv10', None), ('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('cgc_size_t', 'tlv10', '', '3'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { const char * tlv12 = form -> cur_page -> title ; const char tlv11 [ ] = "Fin" ; cgc_size_t tlv10 ; tlv10 = 3 ; tlv3 = cgc_strncmp ( tlv12 , tlv11 , tlv10 ) ; }
ignore sibs: ['if ( tlv3 == 0 ) { cgc_printf ( "\\n*********Final Screening:*********\\n" , form -> cur_page -> title ) ; } else { cgc_printf ( "\\n*********%s:*********\\n" , form -> cur_page -> title ) ; }', '}', '}', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: const char *, var: tlv12
1 : |  decl_scope  | type: const char *, var: tlv11
2 : |  decl_scope  | type: const char, var: tlv11 [ ]
3 : |  decl_scope  | type: cgc_size_t, var: tlv10
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: question_t *, var: cur
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: cgc_size_t, value: 3
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { cgc_printf ( "\n*********Final Screening:*********\n" , form -> cur_page -> title ) ; }
ignore sibs: ['else', '{ cgc_printf ( "\\n*********%s:*********\\n" , form -> cur_page -> title ) ; }', '}', '}', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: tlv1
3 : |  decl_scope  | type: int, var: tlv2
4 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: int, value: tlv3
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { cgc_printf ( "\n*********%s:*********\n" , form -> cur_page -> title ) ; }
ignore sibs: ['}', '}', 'for ( ; cur != NULL ; cur = cur -> next ) { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\\n" , cur -> title ) ; } }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: tlv1
3 : |  decl_scope  | type: int, var: tlv2
4 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
===> context { if ( cur -> answer != NULL ) { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } else { cgc_printf ( "%s=\n" , cur -> title ) ; } }
ignore sibs: ['}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: question_t *, value: cur -> next
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '', '', '']
===> context { cgc_printf ( "%s=%s\n" , cur -> title , cur -> answer ) ; }
ignore sibs: ['else', '{ cgc_printf ( "%s=\\n" , cur -> title ) ; }', '}', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: question_t *, value: cur -> next
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
2 : |compare_scopes| type: question_t *, value: cur -> answer
3 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s=\n" , cur -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s=\n" , cur -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('question_t *', 'cur', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
===> context { cgc_printf ( "%s=\n" , cur -> title ) ; }
ignore sibs: ['}', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: question_t *, var: cur
2 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: question_t *, value: cur -> next
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
compound scope 0 : { cgc_printf ( "\nType **next to continue\n" ) ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\nType **next to continue\n" ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\nType **next to continue\n" ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { cgc_printf ( "\nType **next to continue\n" ) ; }
ignore sibs: []
=======END=======
compound scope 0 : { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> next == NULL ) { return 1 ; } form -> cur_page = form -> cur_page -> next ; form -> cur_question = form -> cur_page -> questions ; return 0 ; }
compound scope 1 : { return - 1 ; }
compound scope 2 : { return 1 ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> next == NULL ) { return 1 ; } form -> cur_page = form -> cur_page -> next ; form -> cur_question = form -> cur_page -> questions ; return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> next == NULL ) { return 1 ; } form -> cur_page = form -> cur_page -> next ; form -> cur_question = form -> cur_page -> questions ; return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = [('UNDEF', 'form -> cur_page', '', 'form -> cur_page -> next'), ('UNDEF', 'form -> cur_question', '', 'form -> cur_page -> questions')]
compares = []
===> context { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> next == NULL ) { return 1 ; } form -> cur_page = form -> cur_page -> next ; form -> cur_question = form -> cur_page -> questions ; return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
0 : | assign_scope | type: UNDEF, value: form -> cur_page -> next
1 : | assign_scope | type: UNDEF, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['if ( form -> cur_page -> next == NULL ) { return 1 ; }', 'form -> cur_page = form -> cur_page -> next ;', 'form -> cur_question = form -> cur_page -> questions ;', 'return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
0 : |compare_scopes| type: form_t *, value: form -> cur_page
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = ['', '']
===> context { return 1 ; }
ignore sibs: ['form -> cur_page = form -> cur_page -> next ;', 'form -> cur_question = form -> cur_page -> questions ;', 'return 0 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
0 : |compare_scopes| type: form_t *, value: form -> cur_page -> next
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
compound scope 0 : { if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } }
compound scope 1 : { cgc_printf ( "%s" , form -> ending ) ; }
compound scope 2 : { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } }
compound scope 3 : { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 4 : { cgc_printf ( "\nFinal Questions\n" ) ; }
compound scope 5 : { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
===> context { if ( form -> cur_page -> next -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; } else { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> ending ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> ending ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( "%s" , form -> ending ) ; }
ignore sibs: ['else', '{ int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\\nFinal Questions\\n" ) ; } else { cgc_printf ( "\\n%s Form\\n" , form -> cur_page -> next -> title ) ; } }', '}']
0 : |  decl_scope  | type: form_t *, var: form
0 : |compare_scopes| type: form_t *, value: form -> cur_page -> next -> title
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } } ] 
p_decls = [('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('int', 'tlv1', None), ('form_t *', 'form', None)]
assigns = []
compares = []
===> context { int tlv1 ; { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 == 0 ) { cgc_printf ( "\nFinal Questions\n" ) ; } else { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } }
ignore sibs: ['}']
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: form_t *, var: form
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('const char *', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None)]
assigns = [('cgc_size_t', 'tlv2', '', '3')]
compares = []
decls = [('const char *', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None)]
assigns = [('cgc_size_t', 'tlv2', '', '3')]
compares = []
decls = [('const char *', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv2', '', '3')]
compares = []
===> context { const char * tlv4 = form -> cur_page -> next -> title ; const char tlv3 [ ] = "Fin" ; cgc_size_t tlv2 ; tlv2 = 3 ; tlv1 = cgc_strncmp ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { cgc_printf ( "\\nFinal Questions\\n" ) ; } else { cgc_printf ( "\\n%s Form\\n" , form -> cur_page -> next -> title ) ; }', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv4
1 : |  decl_scope  | type: const char *, var: tlv3
2 : |  decl_scope  | type: const char, var: tlv3 [ ]
3 : |  decl_scope  | type: cgc_size_t, var: tlv2
4 : |  decl_scope  | type: form_t *, var: form
5 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: 3
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\nFinal Questions\n" ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\nFinal Questions\n" ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( "\nFinal Questions\n" ) ; }
ignore sibs: ['else', '{ cgc_printf ( "\\n%s Form\\n" , form -> cur_page -> next -> title ) ; }', '}', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: tlv1
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'tlv1', None)]
assigns = []
compares = []
===> context { cgc_printf ( "\n%s Form\n" , form -> cur_page -> next -> title ) ; }
ignore sibs: ['}', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: tlv1
=======END=======
compound scope 0 : { if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } }
compound scope 1 : { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; }
compound scope 2 : { cgc_printf ( "%s: " , q -> title ) ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('question_t *', 'q', None)]
assigns = []
compares = []
===> context { if ( q -> hint != NULL ) { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } else { cgc_printf ( "%s: " , q -> title ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: question_t *, var: q
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('question_t *', 'q', None)]
assigns = []
compares = []
decls = [('question_t *', 'q', None)]
assigns = []
compares = []
decls = [('question_t *', 'q', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( "%s%s: " , q -> title , q -> hint ) ; }
ignore sibs: ['else', '{ cgc_printf ( "%s: " , q -> title ) ; }', '}']
0 : |  decl_scope  | type: question_t *, var: q
0 : |compare_scopes| type: question_t *, value: q -> hint
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s: " , q -> title ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s: " , q -> title ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('question_t *', 'q', None)]
assigns = []
compares = []
decls = [('question_t *', 'q', None)]
assigns = []
compares = []
===> context { cgc_printf ( "%s: " , q -> title ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: question_t *, var: q
=======END=======
compound scope 0 : { int ret ; if ( form -> cur_page -> title == NULL ) { return 1 ; } if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 2 ; } while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } return 1 ; }
compound scope 1 : { return 1 ; }
compound scope 2 : { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; }
compound scope 3 : { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; }
compound scope 4 : { return - 1 ; }
compound scope 5 : { return 2 ; }
compound scope 6 : { form -> cur_question = form -> cur_question -> next ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; if ( form -> cur_page -> title == NULL ) { return 1 ; } if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 2 ; } while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; if ( form -> cur_page -> title == NULL ) { return 1 ; } if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 2 ; } while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } return 1 ; } ] 
p_decls = [('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
===> context { int ret ; if ( form -> cur_page -> title == NULL ) { return 1 ; } if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 2 ; } while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; } return 1 ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = ['', '']
===> context { return 1 ; }
ignore sibs: ['if ( ! form -> cur_page -> completed ) { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\\n" ) ; return 1 ; }', '{ form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; }', 'if ( ret < 0 ) { return - 1 ; }', 'if ( ret != 0 ) { return 2 ; }', 'while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: int, var: ret
0 : |compare_scopes| type: form_t *, value: form -> cur_page -> title
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = []
===> context { cgc_print_next_title ( form ) ; cgc_printf ( "You must complete the previous page before proceeding to this page\n" ) ; return 1 ; }
ignore sibs: ['{ form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; }', 'if ( ret < 0 ) { return - 1 ; }', 'if ( ret != 0 ) { return 2 ; }', 'while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: int, var: ret
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; } ] 
p_decls = [('form_t *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('form_t *', 'tlv1', '', 'form')]
compares = []
decls = [('form_t *', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = [('form_t *', 'tlv1', '', 'form')]
compares = []
===> context { form_t * tlv1 ; tlv1 = form ; ret = cgc_next_page ( tlv1 ) ; }
ignore sibs: ['if ( ret < 0 ) { return - 1 ; }', 'if ( ret != 0 ) { return 2 ; }', 'while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: tlv1
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: form_t *, value: form
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['if ( ret != 0 ) { return 2 ; }', 'while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: int, var: ret
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 2 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 2 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = []
compares = ['', '']
===> context { return 2 ; }
ignore sibs: ['while ( form -> cur_question != NULL && form -> cur_question -> next != NULL && form -> cur_question -> answer != NULL ) { form -> cur_question = form -> cur_question -> next ; }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: int, var: ret
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form -> cur_question = form -> cur_question -> next ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form -> cur_question = form -> cur_question -> next ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('UNDEF', 'form -> cur_question', '', 'form -> cur_question -> next')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = [('UNDEF', 'form -> cur_question', '', 'form -> cur_question -> next')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('int', 'ret', None)]
assigns = [('UNDEF', 'form -> cur_question', '', 'form -> cur_question -> next')]
compares = ['', '', '', '', '', '']
===> context { form -> cur_question = form -> cur_question -> next ; }
ignore sibs: ['return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: UNDEF, value: form -> cur_question -> next
0 : |compare_scopes| type: form_t *, value: form -> cur_question
1 : |compare_scopes| type: form_t *, value: NULL
2 : |compare_scopes| type: form_t *, value: form -> cur_question -> next
3 : |compare_scopes| type: form_t *, value: NULL
4 : |compare_scopes| type: form_t *, value: form -> cur_question -> answer
5 : |compare_scopes| type: form_t *, value: NULL
=======END=======
compound scope 0 : { cgc_printf ( "Thank you!\n" ) ; cgc_exit ( 0 ) ; return 0 ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Thank you!\n" ) ; cgc_exit ( 0 ) ; return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Thank you!\n" ) ; cgc_exit ( 0 ) ; return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
===> context { cgc_printf ( "Thank you!\n" ) ; cgc_exit ( 0 ) ; return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
=======END=======
compound scope 0 : { cgc_printf ( "%s" , form -> help ) ; return 1 ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> help ) ; return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> help ) ; return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
===> context { cgc_printf ( "%s" , form -> help ) ; return 1 ; }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
=======END=======
compound scope 0 : { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } form -> cur_page = form -> cur_page -> prev ; form -> cur_question = form -> cur_page -> questions ; return 1 ; }
compound scope 1 : { return - 1 ; }
compound scope 2 : { cgc_print_title ( form ) ; return 0 ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } form -> cur_page = form -> cur_page -> prev ; form -> cur_question = form -> cur_page -> questions ; return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } form -> cur_page = form -> cur_page -> prev ; form -> cur_question = form -> cur_page -> questions ; return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('UNDEF', 'form -> cur_page', '', 'form -> cur_page -> prev'), ('UNDEF', 'form -> cur_question', '', 'form -> cur_page -> questions')]
compares = []
===> context { if ( form -> cur_page == NULL ) { return - 1 ; } if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; } form -> cur_page = form -> cur_page -> prev ; form -> cur_question = form -> cur_page -> questions ; return 1 ; }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
0 : | assign_scope | type: UNDEF, value: form -> cur_page -> prev
1 : | assign_scope | type: UNDEF, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['if ( form -> cur_page -> prev == NULL ) { cgc_print_title ( form ) ; return 0 ; }', 'form -> cur_page = form -> cur_page -> prev ;', 'form -> cur_question = form -> cur_page -> questions ;', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
0 : |compare_scopes| type: form_t *, value: form -> cur_page
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_title ( form ) ; return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_title ( form ) ; return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = ['', '']
===> context { cgc_print_title ( form ) ; return 0 ; }
ignore sibs: ['form -> cur_page = form -> cur_page -> prev ;', 'form -> cur_question = form -> cur_page -> questions ;', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
0 : |compare_scopes| type: form_t *, value: form -> cur_page -> prev
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
compound scope 0 : { question_t * cur ; char * input_buf ; if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } if ( arg == NULL ) { return 1 ; } cur = form -> cur_page -> questions ; for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } if ( input_buf == NULL ) { return - 1 ; } cgc_prompt_q ( cur ) ; int tlv1 ; { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } if ( tlv1 < 0 ) { return - 1 ; } if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } return 1 ; }
compound scope 1 : { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; }
compound scope 2 : { return 1 ; }
compound scope 3 : { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } }
compound scope 4 : { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; }
compound scope 5 : { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; }
compound scope 6 : { break ; }
compound scope 7 : { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
compound scope 8 : { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }
compound scope 9 : { return - 1 ; }
compound scope 10 : { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }
compound scope 11 : { return - 1 ; }
compound scope 12 : { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }
compound scope 13 : { cgc_free ( input_buf ) ; }
compound scope 14 : { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } }
compound scope 15 : { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; }
compound scope 16 : { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
compound scope 17 : { cgc_free ( input_buf ) ; }
compound scope 18 : { cur -> answer = input_buf ; }
compound scope 19 : { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }
compound scope 20 : { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; }
compound scope 21 : { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; }
compound scope 22 : { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; }
compound scope 23 : { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; }
compound scope 24 : { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }
compound scope 25 : { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; }
len(compound_scope) : 26
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * cur ; char * input_buf ; if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } if ( arg == NULL ) { return 1 ; } cur = form -> cur_page -> questions ; for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } if ( input_buf == NULL ) { return - 1 ; } cgc_prompt_q ( cur ) ; int tlv1 ; { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } if ( tlv1 < 0 ) { return - 1 ; } if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * cur ; char * input_buf ; if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } if ( arg == NULL ) { return 1 ; } cur = form -> cur_page -> questions ; for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } if ( input_buf == NULL ) { return - 1 ; } cgc_prompt_q ( cur ) ; int tlv1 ; { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } if ( tlv1 < 0 ) { return - 1 ; } if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } return 1 ; } ] 
p_decls = [('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { question_t * cur ; char * input_buf ; if ( ! form -> cur_page -> completed ) { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } if ( arg == NULL ) { return 1 ; } cur = form -> cur_page -> questions ; for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } if ( cur == NULL ) { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } if ( input_buf == NULL ) { return - 1 ; } cgc_prompt_q ( cur ) ; int tlv1 ; { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } if ( tlv1 < 0 ) { return - 1 ; } if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } return 1 ; }
ignore sibs: []
0 : |  decl_scope  | type: question_t *, var: cur
1 : |  decl_scope  | type: char *, var: input_buf
2 : |  decl_scope  | type: int, var: tlv1
3 : |  decl_scope  | type: form_t *, var: form
4 : |  decl_scope  | type: char *, var: arg
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = []
compares = []
===> context { cgc_printf ( "Cannot update field until all fields are inputted\n" ) ; return 1 ; }
ignore sibs: ['if ( arg == NULL ) { return 1 ; }', 'cur = form -> cur_page -> questions ;', 'for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } }', 'if ( cur == NULL ) { cgc_printf ( "Could not find specified field\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', '{ cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }', 'if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = []
compares = ['', '']
===> context { return 1 ; }
ignore sibs: ['cur = form -> cur_page -> questions ;', 'for ( ; cur != NULL ; cur = cur -> next ) { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } }', 'if ( cur == NULL ) { cgc_printf ( "Could not find specified field\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', '{ cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }', 'if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
0 : |compare_scopes| type: char *, value: arg
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } } ] 
p_decls = [('int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('int', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('int', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
===> context { int tlv2 ; { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } if ( tlv2 == 0 ) { break ; } }
ignore sibs: ['if ( cur == NULL ) { cgc_printf ( "Could not find specified field\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', '{ cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }', 'if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: question_t *, value: cur -> next
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; } ] 
p_decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('cgc_size_t', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
===> context { const char * tlv8 = cur -> title ; const char * tlv7 = arg ; cgc_size_t tlv6 ; { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ; }
ignore sibs: ['if ( tlv2 == 0 ) { break ; }', '}', 'if ( cur == NULL ) { cgc_printf ( "Could not find specified field\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', '{ cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }', 'if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv8
1 : |  decl_scope  | type: const char *, var: tlv7
2 : |  decl_scope  | type: cgc_size_t, var: tlv6
3 : |  decl_scope  | type: form_t *, var: form
4 : |  decl_scope  | type: char *, var: arg
5 : |  decl_scope  | type: question_t *, var: cur
6 : |  decl_scope  | type: char *, var: input_buf
7 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: question_t *, value: cur -> next
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; } ] 
p_decls = [('const char *', 'tlv16', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv16', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'cgc_strlen ( tlv16 )')]
compares = []
decls = [('const char *', 'tlv16', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'cgc_strlen ( tlv16 )'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv16', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'cgc_strlen ( tlv16 )'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('const char *', 'tlv16', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv2', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'cgc_strlen ( tlv16 )'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('const char *', 'tlv16', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv2', None), ('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('cgc_size_t', 'tlv6', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'cgc_strlen ( tlv16 )'), ('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
===> context { const char * tlv16 = cur -> title ; tlv6 = cgc_strlen ( tlv16 ) ; }
ignore sibs: ['tlv2 = cgc_strncmp ( tlv8 , tlv7 , tlv6 ) ;', '}', 'if ( tlv2 == 0 ) { break ; }', '}', 'if ( cur == NULL ) { cgc_printf ( "Could not find specified field\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', '{ cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }', 'if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv16
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
5 : |  decl_scope  | type: int, var: tlv2
6 : |  decl_scope  | type: const char *, var: tlv8
7 : |  decl_scope  | type: const char *, var: tlv7
8 : |  decl_scope  | type: cgc_size_t, var: tlv6
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv16 )
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
2 : | assign_scope | type: question_t *, value: cur -> next
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv2', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions'), ('question_t *', 'cur', '', 'cur -> next')]
compares = ['', '', '', '']
===> context { break ; }
ignore sibs: ['}', 'if ( cur == NULL ) { cgc_printf ( "Could not find specified field\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', '{ cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }', 'if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
1 : | assign_scope | type: question_t *, value: cur -> next
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
2 : |compare_scopes| type: int, value: tlv2
3 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { cgc_printf ( "Could not find specified field\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
ignore sibs: ['{ cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }', 'if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: question_t *, value: cur
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv4', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('cgc_size_t', 'tlv4', '', 'LINE_SIZE')]
compares = []
decls = [('cgc_size_t', 'tlv4', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('cgc_size_t', 'tlv4', '', 'LINE_SIZE'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { cgc_size_t tlv4 ; tlv4 = LINE_SIZE ; input_buf = cgc_malloc ( tlv4 ) ; }
ignore sibs: ['if ( input_buf == NULL ) { return - 1 ; }', 'cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv4
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
0 : | assign_scope | type: cgc_size_t, value: LINE_SIZE
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['cgc_prompt_q ( cur ) ;', 'int tlv1 ;', '{ char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }', 'if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: char *, value: input_buf
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; } ] 
p_decls = [('char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('char *', 'tlv5', '', 'input_buf')]
compares = []
decls = [('char *', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv5', '', 'input_buf'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { char * tlv5 ; tlv5 = input_buf ; tlv1 = cgc_read_line ( tlv5 ) ; }
ignore sibs: ['if ( tlv1 < 0 ) { return - 1 ; }', 'if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv5
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
5 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: input_buf
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['if ( ( cgc_strlen ( input_buf ) == 0 ) && cur -> optional ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'NULL')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'NULL'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'NULL'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } cur -> answer = NULL ; return 1 ; }
ignore sibs: ['if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: UNDEF, value: NULL
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: UNDEF, value: cgc_strlen ( input_buf )
1 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( input_buf ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( input_buf ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '', '', '']
===> context { cgc_free ( input_buf ) ; }
ignore sibs: ['if ( cur -> answer != NULL ) { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } }', 'cur -> answer = NULL ;', 'return 1 ;', '}', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: UNDEF, value: cgc_strlen ( input_buf )
1 : |compare_scopes| type: UNDEF, value: 0
2 : |compare_scopes| type: char *, value: input_buf
3 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '', '', '']
===> context { { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } }
ignore sibs: ['cur -> answer = NULL ;', 'return 1 ;', '}', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: UNDEF, value: cgc_strlen ( input_buf )
1 : |compare_scopes| type: UNDEF, value: 0
2 : |compare_scopes| type: question_t *, value: cur -> answer
3 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; } ] 
p_decls = [('void *', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv12', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('void *', 'tlv12', '', 'cur -> answer')]
compares = []
decls = [('void *', 'tlv12', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv12', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('void *', 'tlv12', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv12', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
decls = [('void *', 'tlv12', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv12', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
decls = [('void *', 'tlv12', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv12', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '', '', '']
decls = [('void *', 'tlv12', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv12', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '', '', '']
===> context { void * tlv12 ; tlv12 = cur -> answer ; cgc_free ( tlv12 ) ; }
ignore sibs: ['}', 'cur -> answer = NULL ;', 'return 1 ;', '}', 'if ( ! cur -> validator ( input_buf ) ) { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\\n" ) ; cgc_printf ( "Update Unsuccessful\\n" ) ; return 1 ; }', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv12
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
5 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: void *, value: cur -> answer
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: UNDEF, value: cgc_strlen ( input_buf )
1 : |compare_scopes| type: UNDEF, value: 0
2 : |compare_scopes| type: question_t *, value: cur -> answer
3 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { if ( input_buf != NULL ) { cgc_free ( input_buf ) ; } cgc_printf ( "Bad input.\n" ) ; cgc_printf ( "Update Unsuccessful\n" ) ; return 1 ; }
ignore sibs: ['if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( input_buf ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( input_buf ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { cgc_free ( input_buf ) ; }
ignore sibs: ['cgc_printf ( "Bad input.\\n" ) ;', 'cgc_printf ( "Update Unsuccessful\\n" ) ;', 'return 1 ;', '}', 'if ( cur -> answer == NULL ) { cur -> answer = input_buf ; } else { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: char *, value: input_buf
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cur -> answer = input_buf ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cur -> answer = input_buf ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'input_buf')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'input_buf'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'input_buf'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { cur -> answer = input_buf ; }
ignore sibs: ['else', '{ int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: UNDEF, value: input_buf
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: question_t *, value: cur -> answer
1 : |compare_scopes| type: question_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } } ] 
p_decls = [('int', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('int', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { int tlv3 ; { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } }
ignore sibs: ['return 1 ;', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
5 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; } ] 
p_decls = [('const char *', 'tlv11', None), ('const char *', 'tlv10', None), ('cgc_size_t', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv11', None), ('const char *', 'tlv10', None), ('cgc_size_t', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv11', None), ('const char *', 'tlv10', None), ('cgc_size_t', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv11', None), ('const char *', 'tlv10', None), ('cgc_size_t', 'tlv9', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { const char * tlv11 = cur -> answer ; const char * tlv10 = input_buf ; cgc_size_t tlv9 ; { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ; }
ignore sibs: ['if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }', '}', 'return 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv11
1 : |  decl_scope  | type: const char *, var: tlv10
2 : |  decl_scope  | type: cgc_size_t, var: tlv9
3 : |  decl_scope  | type: form_t *, var: form
4 : |  decl_scope  | type: char *, var: arg
5 : |  decl_scope  | type: question_t *, var: cur
6 : |  decl_scope  | type: char *, var: input_buf
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; } ] 
p_decls = [('const char *', 'tlv17', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv17', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('cgc_size_t', 'tlv9', '', 'cgc_strlen ( tlv17 )')]
compares = []
decls = [('const char *', 'tlv17', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv9', '', 'cgc_strlen ( tlv17 )'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv17', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('cgc_size_t', 'tlv9', '', 'cgc_strlen ( tlv17 )'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('const char *', 'tlv17', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None), ('const char *', 'tlv11', None), ('const char *', 'tlv10', None), ('cgc_size_t', 'tlv9', None)]
assigns = [('cgc_size_t', 'tlv9', '', 'cgc_strlen ( tlv17 )'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { const char * tlv17 = cur -> answer ; tlv9 = cgc_strlen ( tlv17 ) ; }
ignore sibs: ['tlv3 = cgc_strncmp ( tlv11 , tlv10 , tlv9 ) ;', '}', 'if ( tlv3 == 0 ) { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } else { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }', '}', 'return 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv17
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
5 : |  decl_scope  | type: int, var: tlv1
6 : |  decl_scope  | type: int, var: tlv3
7 : |  decl_scope  | type: const char *, var: tlv11
8 : |  decl_scope  | type: const char *, var: tlv10
9 : |  decl_scope  | type: cgc_size_t, var: tlv9
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv17 )
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } cgc_free ( input_buf ) ; }
ignore sibs: ['else', '{ { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }', '}', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: int, value: tlv3
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; } ] 
p_decls = [('char *', 'tlv14', None), ('const char *', 'tlv13', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv14', None), ('const char *', 'tlv13', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('char *', 'tlv14', '', 'cur -> answer')]
compares = []
decls = [('char *', 'tlv14', None), ('const char *', 'tlv13', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv14', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('char *', 'tlv14', None), ('const char *', 'tlv13', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv14', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('char *', 'tlv14', None), ('const char *', 'tlv13', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv14', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
decls = [('char *', 'tlv14', None), ('const char *', 'tlv13', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv14', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = ['', '']
===> context { char * tlv14 ; tlv14 = cur -> answer ; const char * tlv13 = input_buf ; cgc_strcpy ( tlv14 , tlv13 ) ; }
ignore sibs: ['cgc_free ( input_buf ) ;', '}', 'else', '{ { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }', '}', 'return 1 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv14
1 : |  decl_scope  | type: const char *, var: tlv13
2 : |  decl_scope  | type: form_t *, var: form
3 : |  decl_scope  | type: char *, var: arg
4 : |  decl_scope  | type: question_t *, var: cur
5 : |  decl_scope  | type: char *, var: input_buf
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: char *, value: cur -> answer
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
0 : |compare_scopes| type: int, value: tlv3
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'input_buf')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'input_buf'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('UNDEF', 'cur -> answer', '', 'input_buf'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } cur -> answer = input_buf ; }
ignore sibs: ['}', 'return 1 ;', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: arg
2 : |  decl_scope  | type: question_t *, var: cur
3 : |  decl_scope  | type: char *, var: input_buf
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: UNDEF, value: input_buf
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; } ] 
p_decls = [('void *', 'tlv15', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv15', None), ('form_t *', 'form', None), ('char *', 'arg', None)]
assigns = [('void *', 'tlv15', '', 'cur -> answer')]
compares = []
decls = [('void *', 'tlv15', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv15', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('void *', 'tlv15', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv15', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
decls = [('void *', 'tlv15', None), ('form_t *', 'form', None), ('char *', 'arg', None), ('question_t *', 'cur', None), ('char *', 'input_buf', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv15', '', 'cur -> answer'), ('question_t *', 'cur', '', 'form -> cur_page -> questions')]
compares = []
===> context { void * tlv15 ; tlv15 = cur -> answer ; cgc_free ( tlv15 ) ; }
ignore sibs: ['cur -> answer = input_buf ;', '}', '}', 'return 1 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv15
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: arg
3 : |  decl_scope  | type: question_t *, var: cur
4 : |  decl_scope  | type: char *, var: input_buf
5 : |  decl_scope  | type: int, var: tlv1
6 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: void *, value: cur -> answer
1 : | assign_scope | type: question_t *, value: form -> cur_page -> questions
=======END=======
compound scope 0 : { if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } if ( with_title ) { cgc_print_title ( form ) ; } if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } }
compound scope 1 : { cgc_printf ( "%s" , form -> ending ) ; return ; }
compound scope 2 : { cgc_print_title ( form ) ; }
compound scope 3 : { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; }
compound scope 4 : { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } if ( with_title ) { cgc_print_title ( form ) ; } if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } if ( with_title ) { cgc_print_title ( form ) ; } if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
===> context { if ( form -> cur_page -> title == NULL ) { cgc_printf ( "%s" , form -> ending ) ; return ; } if ( with_title ) { cgc_print_title ( form ) ; } if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: with_title
2 : |  decl_scope  | type: int, var: done
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> ending ) ; return ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> ending ) ; return ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( "%s" , form -> ending ) ; return ; }
ignore sibs: ['if ( with_title ) { cgc_print_title ( form ) ; }', 'if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; }', '{ question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: with_title
2 : |  decl_scope  | type: int, var: done
0 : |compare_scopes| type: form_t *, value: form -> cur_page -> title
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_title ( form ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_title ( form ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
===> context { cgc_print_title ( form ) ; }
ignore sibs: ['if ( form -> cur_page -> completed ) { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; }', '{ question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: with_title
2 : |  decl_scope  | type: int, var: done
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = []
compares = []
===> context { cgc_print_page ( form ) ; cgc_prompt_next ( ) ; return ; }
ignore sibs: ['{ question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: int, var: with_title
2 : |  decl_scope  | type: int, var: done
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; } ] 
p_decls = [('question_t *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('question_t *', 'tlv1', None), ('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = [('question_t *', 'tlv1', '', 'form -> cur_question')]
compares = []
decls = [('question_t *', 'tlv1', None), ('form_t *', 'form', None), ('int', 'with_title', None), ('int', 'done', None)]
assigns = [('question_t *', 'tlv1', '', 'form -> cur_question')]
compares = []
===> context { question_t * tlv1 ; tlv1 = form -> cur_question ; cgc_prompt_q ( tlv1 ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: question_t *, var: tlv1
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: int, var: with_title
3 : |  decl_scope  | type: int, var: done
0 : | assign_scope | type: question_t *, value: form -> cur_question
=======END=======
compound scope 0 : { int ret ; static int tlv1 ; { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } cgc_size_t tlv2 ; { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } if ( ret < 0 ) { return - 1 ; } else { return 0 ; } }
compound scope 1 : { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; }
compound scope 2 : { return cgc_handle_cmd ( form , buf ) ; }
compound scope 3 : { return 1 ; }
compound scope 4 : { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; }
compound scope 5 : { if ( ! form -> cur_question -> optional ) { return 0 ; } }
compound scope 6 : { return 0 ; }
compound scope 7 : { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }
compound scope 8 : { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; }
compound scope 9 : { return - 1 ; }
compound scope 10 : { return 0 ; }
compound scope 11 : { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }
compound scope 12 : { return - 1 ; }
compound scope 13 : { return 0 ; }
len(compound_scope) : 14
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; static int tlv1 ; { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } cgc_size_t tlv2 ; { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } if ( ret < 0 ) { return - 1 ; } else { return 0 ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; static int tlv1 ; { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } cgc_size_t tlv2 ; { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } if ( ret < 0 ) { return - 1 ; } else { return 0 ; } } ] 
p_decls = [('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
===> context { int ret ; static int tlv1 ; { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; } if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; } cgc_size_t tlv2 ; { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } if ( ret < 0 ) { return - 1 ; } else { return 0 ; } }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: static int, var: tlv1
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: form_t *, var: form
4 : |  decl_scope  | type: char *, var: buf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; } ] 
p_decls = [('form_t *', 'tlv4', None), ('char *', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'tlv4', None), ('char *', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('form_t *', 'tlv4', '', 'form'), ('char *', 'tlv3', '', 'buf')]
compares = []
decls = [('form_t *', 'tlv4', None), ('char *', 'tlv3', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None)]
assigns = [('form_t *', 'tlv4', '', 'form'), ('char *', 'tlv3', '', 'buf')]
compares = []
===> context { form_t * tlv4 ; tlv4 = form ; char * tlv3 ; tlv3 = buf ; tlv1 = cgc_is_cmd ( tlv4 , tlv3 ) ; }
ignore sibs: ['if ( tlv1 ) { return cgc_handle_cmd ( form , buf ) ; }', 'if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; }', 'cgc_size_t tlv2 ;', '{ const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; }', 'if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: tlv4
1 : |  decl_scope  | type: char *, var: tlv3
2 : |  decl_scope  | type: form_t *, var: form
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: static int, var: tlv1
0 : | assign_scope | type: form_t *, value: form
1 : | assign_scope | type: char *, value: buf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return cgc_handle_cmd ( form , buf ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return cgc_handle_cmd ( form , buf ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None)]
assigns = []
compares = []
===> context { return cgc_handle_cmd ( form , buf ) ; }
ignore sibs: ['if ( form -> cur_page -> completed || form -> cur_question == NULL ) { return 1 ; }', 'cgc_size_t tlv2 ;', '{ const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; }', 'if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None)]
assigns = []
compares = ['', '']
===> context { return 1 ; }
ignore sibs: ['cgc_size_t tlv2 ;', '{ const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; }', 'if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
0 : |compare_scopes| type: form_t *, value: form -> cur_question
1 : |compare_scopes| type: form_t *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv5 )')]
compares = []
decls = [('const char *', 'tlv5', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv5 )')]
compares = []
===> context { const char * tlv5 = buf ; tlv2 = cgc_strlen ( tlv5 ) ; }
ignore sibs: ['if ( tlv2 == 0 ) { if ( ! form -> cur_question -> optional ) { return 0 ; } } else { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: const char *, var: tlv5
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: static int, var: tlv1
5 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv5 )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ! form -> cur_question -> optional ) { return 0 ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ! form -> cur_question -> optional ) { return 0 ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = ['', '']
===> context { if ( ! form -> cur_question -> optional ) { return 0 ; } }
ignore sibs: ['else', '{ { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : |compare_scopes| type: cgc_size_t, value: tlv2
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = ['', '']
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = ['', '']
===> context { return 0 ; }
ignore sibs: ['}', 'else', '{ { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : |compare_scopes| type: cgc_size_t, value: tlv2
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
===> context { { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } if ( ret < 0 ) { return - 1 ; } if ( ret != 0 ) { return 0 ; } }
ignore sibs: ['{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; } ] 
p_decls = [('form_t *', 'tlv8', None), ('char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'tlv8', None), ('char *', 'tlv7', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('form_t *', 'tlv8', '', 'form'), ('char *', 'tlv7', '', 'buf')]
compares = []
decls = [('form_t *', 'tlv8', None), ('char *', 'tlv7', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = [('form_t *', 'tlv8', '', 'form'), ('char *', 'tlv7', '', 'buf')]
compares = []
decls = [('form_t *', 'tlv8', None), ('char *', 'tlv7', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = [('form_t *', 'tlv8', '', 'form'), ('char *', 'tlv7', '', 'buf')]
compares = []
===> context { form_t * tlv8 ; tlv8 = form ; char * tlv7 ; tlv7 = buf ; ret = cgc_handle_answer ( tlv8 , tlv7 ) ; }
ignore sibs: ['if ( ret < 0 ) { return - 1 ; }', 'if ( ret != 0 ) { return 0 ; }', '}', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: tlv8
1 : |  decl_scope  | type: char *, var: tlv7
2 : |  decl_scope  | type: form_t *, var: form
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: static int, var: tlv1
6 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : | assign_scope | type: form_t *, value: form
1 : | assign_scope | type: char *, value: buf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['if ( ret != 0 ) { return 0 ; }', '}', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = ['', '']
===> context { return 0 ; }
ignore sibs: ['}', '{ form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }', 'if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; } ] 
p_decls = [('form_t *', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = [('form_t *', 'tlv6', '', 'form')]
compares = []
decls = [('form_t *', 'tlv6', None), ('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = [('form_t *', 'tlv6', '', 'form')]
compares = []
===> context { form_t * tlv6 ; tlv6 = form ; ret = cgc_next_question ( tlv6 ) ; }
ignore sibs: ['if ( ret < 0 ) { return - 1 ; } else { return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: tlv6
1 : |  decl_scope  | type: form_t *, var: form
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: static int, var: tlv1
5 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : | assign_scope | type: form_t *, value: form
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['else', '{ return 0 ; }', '}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None), ('char *', 'buf', None)]
assigns = []
compares = []
decls = [('form_t *', 'form', None), ('char *', 'buf', None), ('int', 'ret', None), ('static int', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = []
compares = []
===> context { return 0 ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: form_t *, var: form
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: static int, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
=======END=======
compound scope 0 : { cgc_printf ( "%s" , form -> greeting ) ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> greeting ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "%s" , form -> greeting ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('form_t *', 'form', None)]
assigns = []
compares = []
===> context { cgc_printf ( "%s" , form -> greeting ) ; }
ignore sibs: []
0 : |  decl_scope  | type: form_t *, var: form
=======END=======
def_vars[0]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[1]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : char * p ;
def_vars[2]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : char cmd_buf [ MAX_CMD_SIZE ] ;
def_vars[3]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[4]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : void * tlv4 ;
def_vars[5]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[6]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[7]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv8 = cmd_lbls [ i ] ;
def_vars[8]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv7 = cmd_buf ;
def_vars[9]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = cmd_lbls [ i ] ;
def_vars[10]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv5 ;
def_vars[11]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv9 = cmd_lbls [ i ] ;
def_vars[12]: [cgc_handler_index] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv10 = cmd_lbls [ i ] ;
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char'}'
val_s=>'[('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>)]'
cval_s=>'[]'
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=0/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=1/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
Skipping MAX_CMD_SIZE => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=2/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=3/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=4/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=5/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=6/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/20][j=0/9][dd=10/13][k=0/1] | type: char * ; var : p ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
----
UNIQ_INIT: ('char *','buf','None','None');

==== Scope 1 ====
void fix_ingred_form_0_0_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(buf); }
    {char * p; p = (char *)(buf); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {void * tlv4; tlv4 = (void *)(buf); }
    {void * tlv3; tlv3 = (void *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf); }
}
void fix_ingred_form_0_0(){
fix_ingred_form_0_0_0();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char'}'
val_s=>'[('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>)]'
cval_s=>'[('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c84aeb8>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c8533c8>), ('char *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c853978>), ('char *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c853eb8>)]'
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=0/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
unique : ('char *', 'p', None)
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=0/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=0/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=0/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=1/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=1/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=1/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=1/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
Skipping MAX_CMD_SIZE => #define
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=2/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=2/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=2/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=2/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=3/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=3/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=3/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=3/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=4/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=4/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=4/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=4/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=5/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=5/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=5/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=5/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=6/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=6/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=6/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=6/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*p' - False OR  False
[i=0/20][j=1/9][dd=10/13][k=1/5] | type: char ; var :  ; varinfo :  ; value_node : * p (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,p
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''*'' - False OR  False
[i=0/20][j=1/9][dd=10/13][k=2/5] | type: char ; var :  ; varinfo :  ; value_node : '*' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '*'
 => is literal (False) | is operator (False) '*' [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p-buf' - False OR  False
[i=0/20][j=1/9][dd=10/13][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : p - buf (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,-,buf
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=0/20][j=1/9][dd=10/13][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
not valid - char * p; p = ((char *)* p);

----
UNIQ_INIT: ('char *','p','None','None');

UNIQ_INIT: ('char *','buf','None','None');

----
UNIQ_INIT: ('char *','p','None','None');

UNIQ_INIT: ('char *','buf','None','None');

not valid - char * p; p = ((char *)p - buf);

----
UNIQ_INIT: ('char *','p','None','None');

UNIQ_INIT: ('char *','buf','None','None');

----
UNIQ_INIT: ('char *','p','None','None');

UNIQ_INIT: ('char *','buf','None','None');

==== Scope 1 ====
void fix_ingred_form_0_1_1(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(* p); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(* p); }
    {int tlv1; tlv1 = (int)(* p); }
    {void * tlv4; tlv4 = (void *)(* p); }
    {void * tlv3; tlv3 = (void *)(* p); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(* p); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(* p); }
}
void fix_ingred_form_0_1_2(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)('*'); }
    {char * p; p = (char *)('*'); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)('*'); }
    {int tlv1; tlv1 = (int)('*'); }
    {void * tlv4; tlv4 = (void *)('*'); }
    {void * tlv3; tlv3 = (void *)('*'); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)('*'); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)('*'); }
}
void fix_ingred_form_0_1_3(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(p - buf); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(p - buf); }
    {int tlv1; tlv1 = (int)(p - buf); }
    {void * tlv4; tlv4 = (void *)(p - buf); }
    {void * tlv3; tlv3 = (void *)(p - buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(p - buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(p - buf); }
}
void fix_ingred_form_0_1_4(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(2); }
    {char * p; p = (char *)(2); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(2); }
    {int tlv1; tlv1 = (int)(2); }
    {void * tlv4; tlv4 = (void *)(2); }
    {void * tlv3; tlv3 = (void *)(2); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(2); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(2); }
}
void fix_ingred_form_0_1(){
fix_ingred_form_0_1_1();
fix_ingred_form_0_1_2();
fix_ingred_form_0_1_3();
fix_ingred_form_0_1_4();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char'}'
val_s=>'[('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c8510b8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851c18>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851f28>)]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=0/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=0/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=0/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=1/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=1/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=1/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
Skipping MAX_CMD_SIZE => #define
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=2/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=2/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=2/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=3/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=3/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=3/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=4/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=4/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=4/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=5/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=5/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=5/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=6/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=6/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=6/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/20][j=2/9][dd=10/13][k=1/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/20][j=2/9][dd=10/13][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_CMDS' - False OR  False
[i=0/20][j=2/9][dd=10/13][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : NUM_CMDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_CMDS
 => is literal (False) | is operator (False) NUM_CMDS [vtype=None]
----
UNIQ_INIT: ('int','i','None','None');

not valid - int i; i = ((int)i);

----
UNIQ_INIT: ('int','i','None','None');

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_form_0_2_1(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(0); }
    {char * p; p = (char *)(0); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
}
void fix_ingred_form_0_2_2(){
int i;
    bzero(&i,sizeof(int));
    {char * p; p = (char *)(i); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(i); }
    {int tlv1; tlv1 = (int)(i); }
    {void * tlv4; tlv4 = (void *)(i); }
    {void * tlv3; tlv3 = (void *)(i); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(i); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(i); }
}
void fix_ingred_form_0_2_3(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(NUM_CMDS); }
    {char * p; p = (char *)(NUM_CMDS); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(NUM_CMDS); }
    {int tlv1; tlv1 = (int)(NUM_CMDS); }
    {void * tlv4; tlv4 = (void *)(NUM_CMDS); }
    {void * tlv3; tlv3 = (void *)(NUM_CMDS); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(NUM_CMDS); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(NUM_CMDS); }
}
void fix_ingred_form_0_2(){
fix_ingred_form_0_2_1();
fix_ingred_form_0_2_2();
fix_ingred_form_0_2_3();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c84ceb8>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c844518>), ('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c8510b8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851c18>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851f28>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=0/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
unique : ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None)
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=0/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
unique : ('char *', 'p', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=1/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
not unique: ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=1/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
Skipping MAX_CMD_SIZE => #define
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=2/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
not unique: ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=2/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=3/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
not unique: ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=3/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=4/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
not unique: ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=4/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=5/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
not unique: ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=5/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=6/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
not unique: ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=6/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd_buf' - False OR  False
[i=0/20][j=3/9][dd=10/13][k=0/6] | type: void * ; var : tlv4 ; varinfo :  ; value_node : cmd_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd_buf
 => is literal (False) | is operator (False) cmd_buf [vtype=char *]
BEFORE => literal (False) cmd_buf => char *
AFTER => literal (False) cmd_buf [ MAX_CMD_SIZE ] => char [size=MAX_CMD_SIZE]
Array size is variable => 'MAX_CMD_SIZE'
not unique: ('char', 'cmd_buf [ MAX_CMD_SIZE ]', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=0/20][j=3/9][dd=10/13][k=1/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=char *]
not unique: ('char *', 'p', None) ... continue!
----
UNIQ_INIT: ('char','cmd_buf [ MAX_CMD_SIZE ]','None','None');

UNIQ_INIT: ('char *','p','None','None');

not valid - char * p; p = ((char *)p);

----
UNIQ_INIT: ('char','cmd_buf [ MAX_CMD_SIZE ]','None','None');

UNIQ_INIT: ('char *','p','None','None');

==== Scope 1 ====
void fix_ingred_form_0_3_0(){
char cmd_buf [ MAX_CMD_SIZE ];
    bzero(&cmd_buf,( MAX_CMD_SIZE *sizeof(char) ) );
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
    {int i; i = (int)(cmd_buf); }
    {char * p; p = (char *)(cmd_buf); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(cmd_buf); }
    {int tlv1; tlv1 = (int)(cmd_buf); }
    {void * tlv4; tlv4 = (void *)(cmd_buf); }
    {void * tlv3; tlv3 = (void *)(cmd_buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cmd_buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cmd_buf); }
}
void fix_ingred_form_0_3_1(){
char cmd_buf [ MAX_CMD_SIZE ];
    bzero(&cmd_buf,( MAX_CMD_SIZE *sizeof(char) ) );
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
    {int i; i = (int)(p); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(p); }
    {int tlv1; tlv1 = (int)(p); }
    {void * tlv4; tlv4 = (void *)(p); }
    {void * tlv3; tlv3 = (void *)(p); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(p); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(p); }
}
void fix_ingred_form_0_3(){
fix_ingred_form_0_3_0();
fix_ingred_form_0_3_1();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv9': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85cac8>), ('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c8510b8>), ('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c84ceb8>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c844518>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851c18>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851f28>)]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=0/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
unique : ('const char *', 'tlv9', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=1/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
Skipping MAX_CMD_SIZE => #define
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=2/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=3/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=4/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=5/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=6/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)' - False OR  False
[i=0/20][j=4/9][dd=10/13][k=0/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv9','None','None');

==== Scope 1 ====
void fix_ingred_form_0_4_0(){
char tlv9_ref;
    bzero(&tlv9_ref,1*sizeof(char));
const char * tlv9 = &tlv9_ref;
    {int i; i = (int)(cgc_strlen ( tlv9 )); }
    {char * p; p = (char *)(cgc_strlen ( tlv9 )); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(cgc_strlen ( tlv9 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv9 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv9 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv9 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv9 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv9 )); }
}
void fix_ingred_form_0_4(){
fix_ingred_form_0_4_0();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv8': 'const char *'}'
val_s=>'[('UNDEF', 'cmd_buf ', '[ cgc_strlen ( tlv8 ) ]', <CParser.CParser.AssignmentExpressionContext object at 0x14631c29e748>), ('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c8510b8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851c18>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851f28>)]'
Skipping MAX_CMD_SIZE => #define
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv8': 'const char *', 'tlv1': 'int', 'tlv7': 'const char *', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t'}'
val_s=>'[('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c8510b8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851c18>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851f28>)]'
Skipping MAX_CMD_SIZE => #define
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv8': 'const char *', 'tlv1': 'int', 'tlv7': 'const char *', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t', 'tlv10': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2a94a8>), ('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c8510b8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851c18>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851f28>)]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=0/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
unique : ('const char *', 'tlv10', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=1/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
not unique: ('const char *', 'tlv10', None) ... continue!
 => is literal (False) | is operator (True) )
Skipping MAX_CMD_SIZE => #define
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=2/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
not unique: ('const char *', 'tlv10', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=3/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
not unique: ('const char *', 'tlv10', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=4/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
not unique: ('const char *', 'tlv10', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=5/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
not unique: ('const char *', 'tlv10', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=6/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
not unique: ('const char *', 'tlv10', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv10)' - False OR  False
[i=0/20][j=7/9][dd=10/13][k=0/5] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv10 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv10,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv10 [vtype=const char *]
not unique: ('const char *', 'tlv10', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv10','None','None');

==== Scope 1 ====
void fix_ingred_form_0_7_0(){
char tlv10_ref;
    bzero(&tlv10_ref,1*sizeof(char));
const char * tlv10 = &tlv10_ref;
    {int i; i = (int)(cgc_strlen ( tlv10 )); }
    {char * p; p = (char *)(cgc_strlen ( tlv10 )); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(cgc_strlen ( tlv10 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv10 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv10 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv10 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv10 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv10 )); }
}
void fix_ingred_form_0_7(){
fix_ingred_form_0_7_0();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'i': 'int', 'p': 'char *', 'cmd_buf': 'char *', 'cmd_buf [ MAX_CMD_SIZE ]': 'char', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv8': 'const char *', 'tlv1': 'int', 'tlv7': 'const char *', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t'}'
val_s=>'[('char *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c85a6d8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c8510b8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851c18>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c851f28>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2aa438>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2aa7b8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=0/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=1/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
Skipping MAX_CMD_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=2/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=3/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=4/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=5/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=6/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/20][j=8/9][dd=10/13][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
not valid - int tlv1; tlv1 = ((int)tlv1);

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_form_0_8_4(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {int i; i = (int)(tlv1); }
    {char * p; p = (char *)(tlv1); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(tlv1); }
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {void * tlv3; tlv3 = (void *)(tlv1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv1); }
}
void fix_ingred_form_0_8(){
fix_ingred_form_0_8_4();
}

==== Scope 2 ====
void fix_ingred_form_0_0_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(buf); }
    {char * p; p = (char *)(buf); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {void * tlv4; tlv4 = (void *)(buf); }
    {void * tlv3; tlv3 = (void *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf); }
}
void fix_ingred_form_0_0(){
fix_ingred_form_0_0_0();
}
void fix_ingred_form_0_1_1(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(* p); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(* p); }
    {int tlv1; tlv1 = (int)(* p); }
    {void * tlv4; tlv4 = (void *)(* p); }
    {void * tlv3; tlv3 = (void *)(* p); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(* p); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(* p); }
}
void fix_ingred_form_0_1_2(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)('*'); }
    {char * p; p = (char *)('*'); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)('*'); }
    {int tlv1; tlv1 = (int)('*'); }
    {void * tlv4; tlv4 = (void *)('*'); }
    {void * tlv3; tlv3 = (void *)('*'); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)('*'); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)('*'); }
}
void fix_ingred_form_0_1_3(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(p - buf); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(p - buf); }
    {int tlv1; tlv1 = (int)(p - buf); }
    {void * tlv4; tlv4 = (void *)(p - buf); }
    {void * tlv3; tlv3 = (void *)(p - buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(p - buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(p - buf); }
}
void fix_ingred_form_0_1_4(){
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int i; i = (int)(2); }
    {char * p; p = (char *)(2); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(2); }
    {int tlv1; tlv1 = (int)(2); }
    {void * tlv4; tlv4 = (void *)(2); }
    {void * tlv3; tlv3 = (void *)(2); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(2); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(2); }
}
void fix_ingred_form_0_1(){
fix_ingred_form_0_1_1();
fix_ingred_form_0_1_2();
fix_ingred_form_0_1_3();
fix_ingred_form_0_1_4();
}
void fix_ingred_form_0_2_1(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(0); }
    {char * p; p = (char *)(0); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
}
void fix_ingred_form_0_2_2(){
int i;
    bzero(&i,sizeof(int));
    {char * p; p = (char *)(i); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(i); }
    {int tlv1; tlv1 = (int)(i); }
    {void * tlv4; tlv4 = (void *)(i); }
    {void * tlv3; tlv3 = (void *)(i); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(i); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(i); }
}
void fix_ingred_form_0_2_3(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(NUM_CMDS); }
    {char * p; p = (char *)(NUM_CMDS); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(NUM_CMDS); }
    {int tlv1; tlv1 = (int)(NUM_CMDS); }
    {void * tlv4; tlv4 = (void *)(NUM_CMDS); }
    {void * tlv3; tlv3 = (void *)(NUM_CMDS); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(NUM_CMDS); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(NUM_CMDS); }
}
void fix_ingred_form_0_2(){
fix_ingred_form_0_2_1();
fix_ingred_form_0_2_2();
fix_ingred_form_0_2_3();
}
void fix_ingred_form_0_3_0(){
char cmd_buf [ MAX_CMD_SIZE ];
    bzero(&cmd_buf,( MAX_CMD_SIZE *sizeof(char) ) );
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
    {int i; i = (int)(cmd_buf); }
    {char * p; p = (char *)(cmd_buf); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(cmd_buf); }
    {int tlv1; tlv1 = (int)(cmd_buf); }
    {void * tlv4; tlv4 = (void *)(cmd_buf); }
    {void * tlv3; tlv3 = (void *)(cmd_buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cmd_buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cmd_buf); }
}
void fix_ingred_form_0_3_1(){
char cmd_buf [ MAX_CMD_SIZE ];
    bzero(&cmd_buf,( MAX_CMD_SIZE *sizeof(char) ) );
char p_ref;
    bzero(&p_ref,1*sizeof(char));
char * p = &p_ref;
    {int i; i = (int)(p); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(p); }
    {int tlv1; tlv1 = (int)(p); }
    {void * tlv4; tlv4 = (void *)(p); }
    {void * tlv3; tlv3 = (void *)(p); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(p); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(p); }
}
void fix_ingred_form_0_3(){
fix_ingred_form_0_3_0();
fix_ingred_form_0_3_1();
}
void fix_ingred_form_0_4_0(){
char tlv9_ref;
    bzero(&tlv9_ref,1*sizeof(char));
const char * tlv9 = &tlv9_ref;
    {int i; i = (int)(cgc_strlen ( tlv9 )); }
    {char * p; p = (char *)(cgc_strlen ( tlv9 )); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(cgc_strlen ( tlv9 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv9 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv9 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv9 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv9 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv9 )); }
}
void fix_ingred_form_0_4(){
fix_ingred_form_0_4_0();
}
void fix_ingred_form_0_7_0(){
char tlv10_ref;
    bzero(&tlv10_ref,1*sizeof(char));
const char * tlv10 = &tlv10_ref;
    {int i; i = (int)(cgc_strlen ( tlv10 )); }
    {char * p; p = (char *)(cgc_strlen ( tlv10 )); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(cgc_strlen ( tlv10 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv10 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv10 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv10 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv10 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv10 )); }
}
void fix_ingred_form_0_7(){
fix_ingred_form_0_7_0();
}
void fix_ingred_form_0_8_4(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {int i; i = (int)(tlv1); }
    {char * p; p = (char *)(tlv1); }
    {char cmd_buf [ MAX_CMD_SIZE ]; cmd_buf [ ( MAX_CMD_SIZE )-1 ] = (char)(tlv1); }
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {void * tlv3; tlv3 = (void *)(tlv1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv1); }
}
void fix_ingred_form_0_8(){
fix_ingred_form_0_8_4();
}
void fix_ingred_form_0(){
fix_ingred_form_0_0();
fix_ingred_form_0_1();
fix_ingred_form_0_2();
fix_ingred_form_0_3();
fix_ingred_form_0_4();
fix_ingred_form_0_7();
fix_ingred_form_0_8();
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_form_0_0_0();
void fix_ingred_form_0_0();
void fix_ingred_form_0_1_1();
void fix_ingred_form_0_1_2();
void fix_ingred_form_0_1_3();
void fix_ingred_form_0_1_4();
void fix_ingred_form_0_1();
void fix_ingred_form_0_2_1();
void fix_ingred_form_0_2_2();
void fix_ingred_form_0_2_3();
void fix_ingred_form_0_2();
void fix_ingred_form_0_3_0();
void fix_ingred_form_0_3_1();
void fix_ingred_form_0_3();
void fix_ingred_form_0_4_0();
void fix_ingred_form_0_4();
void fix_ingred_form_0_7_0();
void fix_ingred_form_0_7();
void fix_ingred_form_0_8_4();
void fix_ingred_form_0_8();
void fix_ingred_form_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_is_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[1]: [cgc_is_cmd] : <class 'CParser.CParser.DeclarationContext'> : const char tlv4 [ ] = "**" ;
def_vars[2]: [cgc_is_cmd] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv3 = buf ;
def_vars[3]: [cgc_is_cmd] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'tlv1': 'int'}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c2b8c18>)]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv3': 'const char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2ba518>)]'
cval_s=>'[]'
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=1/20][j=1/3][dd=0/4][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=1/20][j=1/3][dd=3/4][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
----
==== Scope 1 ====
void fix_ingred_form_1_1_0(){
    {int tlv1; tlv1 = (int)(2); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(2); }
}
void fix_ingred_form_1_1(){
fix_ingred_form_1_1_0();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv3': 'const char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_1_1_0(){
    {int tlv1; tlv1 = (int)(2); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(2); }
}
void fix_ingred_form_1_1(){
fix_ingred_form_1_1_0();
}
void fix_ingred_form_1(){
fix_ingred_form_1_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_1_1_0();
void fix_ingred_form_1_1();
void fix_ingred_form_1();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [page_complete] : <class 'CParser.CParser.DeclarationContext'> : question_t * cur ;
def_vars[1]: [page_complete] : <class 'CParser.CParser.DeclarationContext'> : int completed ;
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'completed': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2b9358>), ('int', 'completed', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2bd208>)]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5a2eb8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c59f278>)]'
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=2/20][j=0/4][dd=1/2][k=1/4] | type: int ; var : completed ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_form_2_0_1(){
    {int completed; completed = (int)(1); }
}
void fix_ingred_form_2_0(){
fix_ingred_form_2_0_1();
}

sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'completed': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2b9358>), ('int', 'completed', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2bd208>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2bde48>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2bc208>)]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'completed': 'int'}'
val_s=>'[('int', 'completed', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c59af28>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2b9358>), ('int', 'completed', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2bd208>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2bde48>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2bc208>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c59a2e8>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c59a668>)]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/20][j=2/4][dd=1/2][k=0/7] | type: int ; var : completed ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_form_2_2_0(){
    {int completed; completed = (int)(0); }
}
void fix_ingred_form_2_2(){
fix_ingred_form_2_2_0();
}

sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'completed': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c59ecf8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2b9358>), ('int', 'completed', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2bd208>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2bde48>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c2bc208>)]'
==== Scope 2 ====
void fix_ingred_form_2_0_1(){
    {int completed; completed = (int)(1); }
}
void fix_ingred_form_2_0(){
fix_ingred_form_2_0_1();
}
void fix_ingred_form_2_2_0(){
    {int completed; completed = (int)(0); }
}
void fix_ingred_form_2_2(){
fix_ingred_form_2_2_0();
}
void fix_ingred_form_2(){
fix_ingred_form_2_0();
fix_ingred_form_2_2();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_2_0_1();
void fix_ingred_form_2_0();
void fix_ingred_form_2_2_0();
void fix_ingred_form_2_2();
void fix_ingred_form_2();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_print_title] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[1]: [cgc_print_title] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv4 = form -> cur_page -> title ;
def_vars[2]: [cgc_print_title] : <class 'CParser.CParser.DeclarationContext'> : const char tlv3 [ ] = "Fin" ;
def_vars[3]: [cgc_print_title] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
sym_lut=>'{'form': 'form_t *', 'tlv1': 'int'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv2': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c57e7b8>)]'
cval_s=>'[]'
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=3/20][j=1/4][dd=0/4][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=3/20][j=1/4][dd=3/4][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
----
==== Scope 1 ====
void fix_ingred_form_3_1_0(){
    {int tlv1; tlv1 = (int)(3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(3); }
}
void fix_ingred_form_3_1(){
fix_ingred_form_3_1_0();
}

sym_lut=>'{'form': 'form_t *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv2': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c58a518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c58a898>)]'
sym_lut=>'{'form': 'form_t *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv2': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_3_1_0(){
    {int tlv1; tlv1 = (int)(3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(3); }
}
void fix_ingred_form_3_1(){
fix_ingred_form_3_1_0();
}
void fix_ingred_form_3(){
fix_ingred_form_3_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_3_1_0();
void fix_ingred_form_3_1();
void fix_ingred_form_3();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : char * arg ;
def_vars[1]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[2]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : char * cmd ;
def_vars[3]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[4]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[5]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : char * tlv2 ;
def_vars[6]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv1 = buf ;
def_vars[7]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv8 = buf ;
def_vars[8]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv5 ;
def_vars[9]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : const char tlv4 [ ] = " " ;
def_vars[10]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : form_t * tlv7 ;
def_vars[11]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : char * tlv6 ;
def_vars[12]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv9 = buf ;
def_vars[13]: [cgc_handle_cmd] : <class 'CParser.CParser.DeclarationContext'> : cgc_free ( cmd ) ;
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c310c18>)]'
cval_s=>'[]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
is_func_ [f] => '[False, False, True]'
has_multiptr_refs 'form->handlers[i](form,arg)' - True OR  False
[i=4/20][j=0/10][dd=0/14][k=0/1] | type: int ; var : ret ; varinfo :  ; value_node : form -> handlers [ i ] ( form , arg ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (True) || False )]
is_func_ [f] => '[False, False, True]'
has_multiptr_refs 'form->handlers[i](form,arg)' - True OR  False
[i=4/20][j=0/10][dd=1/14][k=0/1] | type: int ; var : ret ; varinfo :  ; value_node : form -> handlers [ i ] ( form , arg ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (True) || False )]
is_func_ [f] => '[False, False, True]'
has_multiptr_refs 'form->handlers[i](form,arg)' - True OR  False
[i=4/20][j=0/10][dd=2/14][k=0/1] | type: int ; var : ret ; varinfo :  ; value_node : form -> handlers [ i ] ( form , arg ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (True) || False )]
is_func_ [f] => '[False, False, True]'
has_multiptr_refs 'form->handlers[i](form,arg)' - True OR  False
[i=4/20][j=0/10][dd=3/14][k=0/1] | type: int ; var : ret ; varinfo :  ; value_node : form -> handlers [ i ] ( form , arg ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (True) || False )]
is_func_ [f] => '[False, False, True]'
has_multiptr_refs 'form->handlers[i](form,arg)' - True OR  False
[i=4/20][j=0/10][dd=4/14][k=0/1] | type: int ; var : ret ; varinfo :  ; value_node : form -> handlers [ i ] ( form , arg ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (True) || False )]
is_func_ [f] => '[False, False, True]'
has_multiptr_refs 'form->handlers[i](form,arg)' - True OR  False
[i=4/20][j=0/10][dd=5/14][k=0/1] | type: int ; var : ret ; varinfo :  ; value_node : form -> handlers [ i ] ( form , arg ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (True) || False )]
is_func_ [f] => '[False, False, True]'
has_multiptr_refs 'form->handlers[i](form,arg)' - True OR  False
[i=4/20][j=0/10][dd=11/14][k=0/1] | type: int ; var : ret ; varinfo :  ; value_node : form -> handlers [ i ] ( form , arg ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (True) || False )]
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'tlv9': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c597358>)]'
cval_s=>'[]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)+1' - False OR  False
[i=4/20][j=2/10][dd=0/14][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
unique : ('const char *', 'tlv9', None)
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)+1' - False OR  False
[i=4/20][j=2/10][dd=1/14][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)+1' - False OR  False
[i=4/20][j=2/10][dd=2/14][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)+1' - False OR  False
[i=4/20][j=2/10][dd=3/14][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)+1' - False OR  False
[i=4/20][j=2/10][dd=4/14][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)+1' - False OR  False
[i=4/20][j=2/10][dd=5/14][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv9)+1' - False OR  False
[i=4/20][j=2/10][dd=11/14][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv9 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv9,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv9 [vtype=const char *]
not unique: ('const char *', 'tlv9', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('const char *','tlv9','None','None');

==== Scope 1 ====
void fix_ingred_form_4_2_0(){
char tlv9_ref;
    bzero(&tlv9_ref,1*sizeof(char));
const char * tlv9 = &tlv9_ref;
    {char * arg; arg = (char *)(cgc_strlen ( tlv9 ) + 1); }
    {int ret; ret = (int)(cgc_strlen ( tlv9 ) + 1); }
    {char * cmd; cmd = (char *)(cgc_strlen ( tlv9 ) + 1); }
    {int i; i = (int)(cgc_strlen ( tlv9 ) + 1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv9 ) + 1); }
    {char * tlv2; tlv2 = (char *)(cgc_strlen ( tlv9 ) + 1); }
    {char * tlv6; tlv6 = (char *)(cgc_strlen ( tlv9 ) + 1); }
}
void fix_ingred_form_4_2(){
fix_ingred_form_4_2_0();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5a5518>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5a5898>)]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=4/20][j=3/10][dd=0/14][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
unique : ('char *', 'arg', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/20][j=3/10][dd=0/14][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=4/20][j=3/10][dd=1/14][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/20][j=3/10][dd=1/14][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=4/20][j=3/10][dd=2/14][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/20][j=3/10][dd=2/14][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=4/20][j=3/10][dd=3/14][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/20][j=3/10][dd=3/14][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=4/20][j=3/10][dd=4/14][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/20][j=3/10][dd=4/14][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=4/20][j=3/10][dd=5/14][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/20][j=3/10][dd=5/14][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=4/20][j=3/10][dd=11/14][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/20][j=3/10][dd=11/14][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
not valid - char * arg; arg = ((char *)arg);

----
UNIQ_INIT: ('char *','arg','None','None');

----
UNIQ_INIT: ('char *','arg','None','None');

==== Scope 1 ====
void fix_ingred_form_4_3_0(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {int ret; ret = (int)(arg); }
    {char * cmd; cmd = (char *)(arg); }
    {int i; i = (int)(arg); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(arg); }
    {char * tlv2; tlv2 = (char *)(arg); }
    {char * tlv6; tlv6 = (char *)(arg); }
}
void fix_ingred_form_4_3_1(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {char * arg; arg = (char *)(NULL); }
    {int ret; ret = (int)(NULL); }
    {char * cmd; cmd = (char *)(NULL); }
    {int i; i = (int)(NULL); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(NULL); }
    {char * tlv2; tlv2 = (char *)(NULL); }
    {char * tlv6; tlv6 = (char *)(NULL); }
}
void fix_ingred_form_4_3(){
fix_ingred_form_4_3_0();
fix_ingred_form_4_3_1();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'const char *'}'
val_s=>'[('char *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5ae208>)]'
cval_s=>'[]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'const char *', 'tlv8': 'const char *'}'
val_s=>'[('UNDEF', 'arg ', '[ cgc_strlen ( tlv8 ) ]', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5ab048>)]'
cval_s=>'[]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'const char *', 'tlv8': 'const char *', 'cmd': 'char *', 'tlv5': 'char * *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char'}'
val_s=>'[('char * *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c3115f8>)]'
cval_s=>'[]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'const char *', 'tlv8': 'const char *', 'cmd': 'char *', 'tlv5': 'char * *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'i': 'int', 'tlv7': 'form_t *', 'tlv6': 'char *'}'
val_s=>'[('form_t *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c317898>), ('char *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c30d828>)]'
cval_s=>'[]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=4/20][j=7/10][dd=0/14][k=1/2] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
unique : ('char *', 'cmd', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=4/20][j=7/10][dd=1/14][k=1/2] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
not unique: ('char *', 'cmd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=4/20][j=7/10][dd=2/14][k=1/2] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
not unique: ('char *', 'cmd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=4/20][j=7/10][dd=3/14][k=1/2] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
not unique: ('char *', 'cmd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=4/20][j=7/10][dd=4/14][k=1/2] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
not unique: ('char *', 'cmd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=4/20][j=7/10][dd=5/14][k=1/2] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
not unique: ('char *', 'cmd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=4/20][j=7/10][dd=11/14][k=1/2] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
not unique: ('char *', 'cmd', None) ... continue!
not valid - char * cmd; cmd = ((char *)cmd);

----
UNIQ_INIT: ('char *','cmd','None','None');

==== Scope 1 ====
void fix_ingred_form_4_7_1(){
char cmd_ref;
    bzero(&cmd_ref,1*sizeof(char));
char * cmd = &cmd_ref;
    {char * arg; arg = (char *)(cmd); }
    {int ret; ret = (int)(cmd); }
    {int i; i = (int)(cmd); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cmd); }
    {char * tlv2; tlv2 = (char *)(cmd); }
    {char * tlv6; tlv6 = (char *)(cmd); }
}
void fix_ingred_form_4_7(){
fix_ingred_form_4_7_1();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'const char *', 'tlv8': 'const char *', 'cmd': 'char *', 'tlv5': 'char * *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'i': 'int', 'tlv7': 'form_t *', 'tlv6': 'char *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c2fff98>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c2ff438>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c2ff748>)]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=4/20][j=8/10][dd=0/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : i (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/20][j=8/10][dd=0/14][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=4/20][j=8/10][dd=1/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : i (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/20][j=8/10][dd=1/14][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=4/20][j=8/10][dd=2/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : i (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/20][j=8/10][dd=2/14][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=4/20][j=8/10][dd=4/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : i (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/20][j=8/10][dd=4/14][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=4/20][j=8/10][dd=5/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : i (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/20][j=8/10][dd=5/14][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=4/20][j=8/10][dd=11/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : i (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/20][j=8/10][dd=11/14][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
UNIQ_INIT: ('int','i','None','None');

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_form_4_8_0(){
int i;
    bzero(&i,sizeof(int));
    {char * arg; arg = (char *)(i); }
    {int ret; ret = (int)(i); }
    {char * cmd; cmd = (char *)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
    {char * tlv2; tlv2 = (char *)(i); }
    {char * tlv6; tlv6 = (char *)(i); }
}
void fix_ingred_form_4_8_2(){
int i;
    bzero(&i,sizeof(int));
    {char * arg; arg = (char *)(0); }
    {int ret; ret = (int)(0); }
    {char * cmd; cmd = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
}
void fix_ingred_form_4_8(){
fix_ingred_form_4_8_0();
fix_ingred_form_4_8_2();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'arg': 'char *', 'tlv3': 'cgc_size_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'const char *', 'tlv8': 'const char *', 'cmd': 'char *', 'tlv5': 'char * *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'i': 'int', 'tlv7': 'form_t *', 'tlv6': 'char *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c310c18>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c30a518>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c30a898>)]'
Checking 'cgc_free( cmd )' - is_func=True, is_func_ptr=False
cgc_free( cmd ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_form_4_2_0(){
char tlv9_ref;
    bzero(&tlv9_ref,1*sizeof(char));
const char * tlv9 = &tlv9_ref;
    {char * arg; arg = (char *)(cgc_strlen ( tlv9 ) + 1); }
    {int ret; ret = (int)(cgc_strlen ( tlv9 ) + 1); }
    {char * cmd; cmd = (char *)(cgc_strlen ( tlv9 ) + 1); }
    {int i; i = (int)(cgc_strlen ( tlv9 ) + 1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv9 ) + 1); }
    {char * tlv2; tlv2 = (char *)(cgc_strlen ( tlv9 ) + 1); }
    {char * tlv6; tlv6 = (char *)(cgc_strlen ( tlv9 ) + 1); }
}
void fix_ingred_form_4_2(){
fix_ingred_form_4_2_0();
}
void fix_ingred_form_4_3_0(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {int ret; ret = (int)(arg); }
    {char * cmd; cmd = (char *)(arg); }
    {int i; i = (int)(arg); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(arg); }
    {char * tlv2; tlv2 = (char *)(arg); }
    {char * tlv6; tlv6 = (char *)(arg); }
}
void fix_ingred_form_4_3_1(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {char * arg; arg = (char *)(NULL); }
    {int ret; ret = (int)(NULL); }
    {char * cmd; cmd = (char *)(NULL); }
    {int i; i = (int)(NULL); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(NULL); }
    {char * tlv2; tlv2 = (char *)(NULL); }
    {char * tlv6; tlv6 = (char *)(NULL); }
}
void fix_ingred_form_4_3(){
fix_ingred_form_4_3_0();
fix_ingred_form_4_3_1();
}
void fix_ingred_form_4_7_1(){
char cmd_ref;
    bzero(&cmd_ref,1*sizeof(char));
char * cmd = &cmd_ref;
    {char * arg; arg = (char *)(cmd); }
    {int ret; ret = (int)(cmd); }
    {int i; i = (int)(cmd); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cmd); }
    {char * tlv2; tlv2 = (char *)(cmd); }
    {char * tlv6; tlv6 = (char *)(cmd); }
}
void fix_ingred_form_4_7(){
fix_ingred_form_4_7_1();
}
void fix_ingred_form_4_8_0(){
int i;
    bzero(&i,sizeof(int));
    {char * arg; arg = (char *)(i); }
    {int ret; ret = (int)(i); }
    {char * cmd; cmd = (char *)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
    {char * tlv2; tlv2 = (char *)(i); }
    {char * tlv6; tlv6 = (char *)(i); }
}
void fix_ingred_form_4_8_2(){
int i;
    bzero(&i,sizeof(int));
    {char * arg; arg = (char *)(0); }
    {int ret; ret = (int)(0); }
    {char * cmd; cmd = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
}
void fix_ingred_form_4_8(){
fix_ingred_form_4_8_0();
fix_ingred_form_4_8_2();
}
void fix_ingred_form_4(){
fix_ingred_form_4_2();
fix_ingred_form_4_3();
fix_ingred_form_4_7();
fix_ingred_form_4_8();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_4_2_0();
void fix_ingred_form_4_2();
void fix_ingred_form_4_3_0();
void fix_ingred_form_4_3_1();
void fix_ingred_form_4_3();
void fix_ingred_form_4_7_1();
void fix_ingred_form_4_7();
void fix_ingred_form_4_8_0();
void fix_ingred_form_4_8_2();
void fix_ingred_form_4_8();
void fix_ingred_form_4();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_handle_answer] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[1]: [cgc_handle_answer] : <class 'CParser.CParser.DeclarationContext'> : char * tlv2 ;
def_vars[2]: [cgc_handle_answer] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv1 = input ;
def_vars[3]: [cgc_handle_answer] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv5 = input ;
def_vars[4]: [cgc_handle_answer] : <class 'CParser.CParser.DeclarationContext'> : void * tlv4 ;
def_vars[5]: [cgc_handle_answer] : <class 'CParser.CParser.DeclarationContext'> : cgc_free ( tlv4 ) ;
sym_lut=>'{'form': 'form_t *', 'input': 'char *'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'input': 'char *'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'input': 'char *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c30e588>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c30e908>)]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'input': 'char *', 'tlv4': 'void *'}'
val_s=>'[('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c320828>)]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c30e588>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c30e908>)]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'form->cur_question->answer' - True OR  False
[i=5/20][j=3/8][dd=0/6][k=0/3] | type: void * ; var : tlv4 ; varinfo :  ; value_node : form -> cur_question -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'form->cur_question->answer' - True OR  False
[i=5/20][j=3/8][dd=1/6][k=0/3] | type: void * ; var : tlv4 ; varinfo :  ; value_node : form -> cur_question -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'form->cur_question->answer' - True OR  False
[i=5/20][j=3/8][dd=4/6][k=0/3] | type: void * ; var : tlv4 ; varinfo :  ; value_node : form -> cur_question -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
sym_lut=>'{'form': 'form_t *', 'input': 'char *', 'tlv3': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'input': 'char *', 'tlv3': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c305d68>)]'
cval_s=>'[]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)+1' - False OR  False
[i=5/20][j=5/8][dd=0/6][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
unique : ('const char *', 'tlv5', None)
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)+1' - False OR  False
[i=5/20][j=5/8][dd=1/6][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)+1' - False OR  False
[i=5/20][j=5/8][dd=4/6][k=0/1] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,),+,1
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('const char *','tlv5','None','None');

==== Scope 1 ====
void fix_ingred_form_5_5_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv5 ) + 1); }
    {char * tlv2; tlv2 = (char *)(cgc_strlen ( tlv5 ) + 1); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv5 ) + 1); }
}
void fix_ingred_form_5_5(){
fix_ingred_form_5_5_0();
}

sym_lut=>'{'form': 'form_t *', 'input': 'char *', 'tlv3': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c303ba8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c303f28>)]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'input': 'char *', 'tlv3': 'cgc_size_t', 'tlv2': 'char *', 'tlv1': 'const char *'}'
val_s=>'[('char *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c307898>)]'
cval_s=>'[]'
Checking 'cgc_free( tlv4 )' - is_func=True, is_func_ptr=False
cgc_free( tlv4 ) is a function.
Skipping.
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'form->cur_question->answer' - True OR  False
[i=5/20][j=7/8][dd=0/6][k=0/1] | type: char * ; var : tlv2 ; varinfo :  ; value_node : form -> cur_question -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'form->cur_question->answer' - True OR  False
[i=5/20][j=7/8][dd=1/6][k=0/1] | type: char * ; var : tlv2 ; varinfo :  ; value_node : form -> cur_question -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'form->cur_question->answer' - True OR  False
[i=5/20][j=7/8][dd=4/6][k=0/1] | type: char * ; var : tlv2 ; varinfo :  ; value_node : form -> cur_question -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
==== Scope 2 ====
void fix_ingred_form_5_5_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv5 ) + 1); }
    {char * tlv2; tlv2 = (char *)(cgc_strlen ( tlv5 ) + 1); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv5 ) + 1); }
}
void fix_ingred_form_5_5(){
fix_ingred_form_5_5_0();
}
void fix_ingred_form_5(){
fix_ingred_form_5_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_5_5_0();
void fix_ingred_form_5_5();
void fix_ingred_form_5();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c67f278>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c67f5f8>)]'
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[('UNDEF', 'form -> cur_page -> completed', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a16d8>)]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bba58>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bbdd8>)]'
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[('UNDEF', 'form -> cur_question', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c690358>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_6(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_6();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : question_t * cur ;
def_vars[1]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[2]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = form -> cur_page -> title ;
def_vars[3]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : const char tlv5 [ ] = "Edu" ;
def_vars[4]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv4 ;
def_vars[5]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[6]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv9 = form -> cur_page -> title ;
def_vars[7]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : const char tlv8 [ ] = "Emp" ;
def_vars[8]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv7 ;
def_vars[9]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[10]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv12 = form -> cur_page -> title ;
def_vars[11]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : const char tlv11 [ ] = "Fin" ;
def_vars[12]: [cgc_print_page] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv10 ;
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c69f518>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[]'
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/20][j=1/13][dd=4/13][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/20][j=1/13][dd=5/13][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/20][j=1/13][dd=8/13][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/20][j=1/13][dd=9/13][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/20][j=1/13][dd=12/13][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
----
==== Scope 1 ====
void fix_ingred_form_7_1_0(){
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(3); }
    {int tlv2; tlv2 = (int)(3); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(3); }
    {int tlv3; tlv3 = (int)(3); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(3); }
}
void fix_ingred_form_7_1(){
fix_ingred_form_7_1_0();
}

sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c68d278>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c68d5f8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=7/20][j=2/13][dd=4/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/20][j=2/13][dd=4/13][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=7/20][j=2/13][dd=5/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/20][j=2/13][dd=5/13][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=7/20][j=2/13][dd=8/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/20][j=2/13][dd=8/13][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=7/20][j=2/13][dd=9/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/20][j=2/13][dd=9/13][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=7/20][j=2/13][dd=12/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/20][j=2/13][dd=12/13][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
UNIQ_INIT: ('int','tlv1','None','None');

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_form_7_2_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv1); }
}
void fix_ingred_form_7_2_2(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
}
void fix_ingred_form_7_2(){
fix_ingred_form_7_2_1();
fix_ingred_form_7_2_2();
}

sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t', 'tlv2': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t', 'tlv2': 'int', 'tlv9': 'const char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6b6c18>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t', 'tlv2': 'int', 'tlv9': 'const char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c681978>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c681cf8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=7/20][j=5/13][dd=1/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
unique : ('int', 'tlv2', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=7/20][j=5/13][dd=4/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=7/20][j=5/13][dd=5/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=7/20][j=5/13][dd=8/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=7/20][j=5/13][dd=9/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=7/20][j=5/13][dd=12/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
not valid - int tlv2; tlv2 = ((int)tlv2);

----
UNIQ_INIT: ('int','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_form_7_5_1(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {int tlv1; tlv1 = (int)(tlv2); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv2); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv2); }
}
void fix_ingred_form_7_5(){
fix_ingred_form_7_5_1();
}

sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t', 'tlv2': 'int', 'tlv9': 'const char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv3': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t', 'tlv2': 'int', 'tlv9': 'const char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv3': 'int', 'tlv12': 'const char *', 'tlv11': 'const char *', 'tlv11 [ ]': 'const char', 'tlv10': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c68e358>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t', 'tlv2': 'int', 'tlv9': 'const char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv3': 'int', 'tlv12': 'const char *', 'tlv11': 'const char *', 'tlv11 [ ]': 'const char', 'tlv10': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6830b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c683438>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=7/20][j=8/13][dd=1/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
unique : ('int', 'tlv3', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=7/20][j=8/13][dd=4/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=7/20][j=8/13][dd=5/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=7/20][j=8/13][dd=8/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=7/20][j=8/13][dd=9/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=7/20][j=8/13][dd=12/13][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
not valid - int tlv3; tlv3 = ((int)tlv3);

----
UNIQ_INIT: ('int','tlv3','None','None');

==== Scope 1 ====
void fix_ingred_form_7_8_1(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {int tlv1; tlv1 = (int)(tlv3); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(tlv3); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv3); }
}
void fix_ingred_form_7_8(){
fix_ingred_form_7_8_1();
}

sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t', 'tlv2': 'int', 'tlv9': 'const char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv3': 'int', 'tlv12': 'const char *', 'tlv11': 'const char *', 'tlv11 [ ]': 'const char', 'tlv10': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6bcac8>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bc128>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bc4a8>)]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6bcac8>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bc128>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bc4a8>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c688898>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c688c18>)]'
sym_lut=>'{'form': 'form_t *', 'cur': 'question_t *', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv4': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6a3668>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c6bcac8>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bc128>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c6bc4a8>)]'
==== Scope 2 ====
void fix_ingred_form_7_1_0(){
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(3); }
    {int tlv2; tlv2 = (int)(3); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(3); }
    {int tlv3; tlv3 = (int)(3); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(3); }
}
void fix_ingred_form_7_1(){
fix_ingred_form_7_1_0();
}
void fix_ingred_form_7_2_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv1); }
}
void fix_ingred_form_7_2_2(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
}
void fix_ingred_form_7_2(){
fix_ingred_form_7_2_1();
fix_ingred_form_7_2_2();
}
void fix_ingred_form_7_5_1(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {int tlv1; tlv1 = (int)(tlv2); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv2); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv2); }
}
void fix_ingred_form_7_5(){
fix_ingred_form_7_5_1();
}
void fix_ingred_form_7_8_1(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {int tlv1; tlv1 = (int)(tlv3); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(tlv3); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv3); }
}
void fix_ingred_form_7_8(){
fix_ingred_form_7_8_1();
}
void fix_ingred_form_7(){
fix_ingred_form_7_1();
fix_ingred_form_7_2();
fix_ingred_form_7_5();
fix_ingred_form_7_8();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_7_1_0();
void fix_ingred_form_7_1();
void fix_ingred_form_7_2_1();
void fix_ingred_form_7_2_2();
void fix_ingred_form_7_2();
void fix_ingred_form_7_5_1();
void fix_ingred_form_7_5();
void fix_ingred_form_7_8_1();
void fix_ingred_form_7_8();
void fix_ingred_form_7();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'void': 'int'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_8(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_8();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[('UNDEF', 'form -> cur_page', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c4a90b8>), ('UNDEF', 'form -> cur_question', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c4a9ba8>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c494358>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4946d8>)]'
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4a7b38>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4a7eb8>)]'
==== Scope 2 ====
void fix_ingred_form_9(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_9();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_print_next_title] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[1]: [cgc_print_next_title] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv4 = form -> cur_page -> next -> title ;
def_vars[2]: [cgc_print_next_title] : <class 'CParser.CParser.DeclarationContext'> : const char tlv3 [ ] = "Fin" ;
def_vars[3]: [cgc_print_next_title] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c492ac8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c492898>)]'
sym_lut=>'{'form': 'form_t *', 'tlv1': 'int'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv2': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c48a518>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv2': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4ae278>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4ae5f8>)]'
sym_lut=>'{'form': 'form_t *', 'tlv1': 'int', 'tlv4': 'const char *', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv2': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_10(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_10();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'q': 'question_t *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'q': 'question_t *'}'
val_s=>'[]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c49e518>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c49e898>)]'
sym_lut=>'{'q': 'question_t *'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_11(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_11();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_handle_next] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[1]: [cgc_handle_next] : <class 'CParser.CParser.DeclarationContext'> : form_t * tlv1 ;
def_vars[2]: [cgc_handle_next] : <class 'CParser.CParser.DeclarationContext'> : cgc_print_next_title ( form ) ;
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'ret': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_print_next_title( form )' - is_func=True, is_func_ptr=False
cgc_print_next_title( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'ret': 'int'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c495cf8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4aa0b8>)]'
Checking 'cgc_print_next_title( form )' - is_func=True, is_func_ptr=False
cgc_print_next_title( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'ret': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_print_next_title( form )' - is_func=True, is_func_ptr=False
cgc_print_next_title( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'ret': 'int', 'tlv1': 'form_t *'}'
val_s=>'[('form_t *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c4973c8>)]'
cval_s=>'[]'
Checking 'cgc_print_next_title( form )' - is_func=True, is_func_ptr=False
cgc_print_next_title( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'ret': 'int', 'tlv1': 'form_t *'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c4abdd8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c47e128>)]'
Checking 'cgc_print_next_title( form )' - is_func=True, is_func_ptr=False
cgc_print_next_title( form ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/20][j=4/7][dd=0/3][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
not valid - int ret; ret = ((int)ret);

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'ret': 'int', 'tlv1': 'form_t *'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4b0518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4b0898>)]'
Checking 'cgc_print_next_title( form )' - is_func=True, is_func_ptr=False
cgc_print_next_title( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'ret': 'int', 'tlv1': 'form_t *'}'
val_s=>'[('UNDEF', 'form -> cur_question', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c4739e8>)]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c442ba8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c442f28>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4584a8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c458828>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c458d68>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c473128>)]'
Checking 'cgc_print_next_title( form )' - is_func=True, is_func_ptr=False
cgc_print_next_title( form ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_form_12(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_12();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'form': 'form_t *', 'arg': 'char *'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_13(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_13();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'form': 'form_t *', 'arg': 'char *'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_14(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_14();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_handle_prev] : <class 'CParser.CParser.DeclarationContext'> : cgc_print_title ( form ) ;
sym_lut=>'{'form': 'form_t *', 'arg': 'char *'}'
val_s=>'[('UNDEF', 'form -> cur_page', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c46d4a8>), ('UNDEF', 'form -> cur_question', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c46df98>)]'
cval_s=>'[]'
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c45b208>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c45b588>)]'
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c47d9e8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c47dd68>)]'
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_form_15(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_15();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : question_t * cur ;
def_vars[1]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : char * input_buf ;
def_vars[2]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : cgc_prompt_q ( cur ) ;
def_vars[3]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[4]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv4 ;
def_vars[5]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : char * tlv5 ;
def_vars[6]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[7]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[8]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv8 = cur -> title ;
def_vars[9]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv7 = arg ;
def_vars[10]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv6 ;
def_vars[11]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv11 = cur -> answer ;
def_vars[12]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv10 = input_buf ;
def_vars[13]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv9 ;
def_vars[14]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : cgc_free ( input_buf ) ;
def_vars[15]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv16 = cur -> title ;
def_vars[16]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv17 = cur -> answer ;
def_vars[17]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : void * tlv12 ;
def_vars[18]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : cgc_free ( tlv12 ) ;
def_vars[19]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : char * tlv14 ;
def_vars[20]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv13 = input_buf ;
def_vars[21]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : void * tlv15 ;
def_vars[22]: [cgc_handle_update] : <class 'CParser.CParser.DeclarationContext'> : cgc_free ( tlv15 ) ;
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c43e0b8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c43e438>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=1/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
unique : ('char *', 'arg', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=1/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=2/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=2/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=3/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=3/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=4/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=4/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=5/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=5/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=6/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=6/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=9/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=9/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=12/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=12/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=15/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=15/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=16/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=16/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'arg' - False OR  False
[i=16/20][j=2/26][dd=18/23][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : arg (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : arg
 => is literal (False) | is operator (False) arg [vtype=char *]
not unique: ('char *', 'arg', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/20][j=2/26][dd=18/23][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
----
UNIQ_INIT: ('char *','arg','None','None');

----
UNIQ_INIT: ('char *','arg','None','None');

==== Scope 1 ====
void fix_ingred_form_16_2_0(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {char * input_buf; input_buf = (char *)(arg); }
    {int tlv1; tlv1 = (int)(arg); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(arg); }
    {char * tlv5; tlv5 = (char *)(arg); }
    {int tlv2; tlv2 = (int)(arg); }
    {int tlv3; tlv3 = (int)(arg); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(arg); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(arg); }
    {void * tlv12; tlv12 = (void *)(arg); }
    {char * tlv14; tlv14 = (char *)(arg); }
    {void * tlv15; tlv15 = (void *)(arg); }
}
void fix_ingred_form_16_2_1(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {char * input_buf; input_buf = (char *)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(NULL); }
    {char * tlv5; tlv5 = (char *)(NULL); }
    {int tlv2; tlv2 = (int)(NULL); }
    {int tlv3; tlv3 = (int)(NULL); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NULL); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(NULL); }
    {void * tlv12; tlv12 = (void *)(NULL); }
    {char * tlv14; tlv14 = (char *)(NULL); }
    {void * tlv15; tlv15 = (void *)(NULL); }
}
void fix_ingred_form_16_2(){
fix_ingred_form_16_2_0();
fix_ingred_form_16_2_1();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv2': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c449c88>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4492e8>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c449668>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv2': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'tlv6': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c449c88>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4492e8>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c449668>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv2': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'tlv6': 'cgc_size_t', 'tlv16': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45dc18>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c449c88>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4492e8>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c449668>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=1/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
unique : ('const char *', 'tlv16', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=2/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=3/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=4/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=5/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=6/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=9/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=12/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=15/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=16/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv16)' - False OR  False
[i=16/20][j=5/26][dd=18/23][k=0/5] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : cgc_strlen ( tlv16 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv16,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv16 [vtype=const char *]
not unique: ('const char *', 'tlv16', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv16','None','None');

==== Scope 1 ====
void fix_ingred_form_16_5_0(){
char tlv16_ref;
    bzero(&tlv16_ref,1*sizeof(char));
const char * tlv16 = &tlv16_ref;
    {char * input_buf; input_buf = (char *)(cgc_strlen ( tlv16 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv16 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv16 )); }
    {char * tlv5; tlv5 = (char *)(cgc_strlen ( tlv16 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv16 )); }
    {int tlv3; tlv3 = (int)(cgc_strlen ( tlv16 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv16 )); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cgc_strlen ( tlv16 )); }
    {void * tlv12; tlv12 = (void *)(cgc_strlen ( tlv16 )); }
    {char * tlv14; tlv14 = (char *)(cgc_strlen ( tlv16 )); }
    {void * tlv15; tlv15 = (void *)(cgc_strlen ( tlv16 )); }
}
void fix_ingred_form_16_5(){
fix_ingred_form_16_5_0();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv2': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'tlv6': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c449c88>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c4492e8>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c449668>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5f1ba8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5f1f28>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=16/20][j=6/26][dd=1/23][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
unique : ('int', 'tlv2', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=16/20][j=6/26][dd=1/23][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=16/20][j=6/26][dd=4/23][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=16/20][j=6/26][dd=4/23][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=16/20][j=6/26][dd=9/23][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=16/20][j=6/26][dd=9/23][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=16/20][j=6/26][dd=12/23][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=16/20][j=6/26][dd=12/23][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=16/20][j=6/26][dd=15/23][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=16/20][j=6/26][dd=15/23][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=16/20][j=6/26][dd=16/23][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=16/20][j=6/26][dd=16/23][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=16/20][j=6/26][dd=18/23][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=16/20][j=6/26][dd=18/23][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
UNIQ_INIT: ('int','tlv2','None','None');

----
UNIQ_INIT: ('int','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_form_16_6_4(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char * input_buf; input_buf = (char *)(tlv2); }
    {char * tlv5; tlv5 = (char *)(tlv2); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv2); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv2); }
    {void * tlv12; tlv12 = (void *)(tlv2); }
    {char * tlv14; tlv14 = (char *)(tlv2); }
    {void * tlv15; tlv15 = (void *)(tlv2); }
}
void fix_ingred_form_16_6_5(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char * input_buf; input_buf = (char *)(0); }
    {char * tlv5; tlv5 = (char *)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(0); }
    {void * tlv12; tlv12 = (void *)(0); }
    {char * tlv14; tlv14 = (char *)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
}
void fix_ingred_form_16_6(){
fix_ingred_form_16_6_4();
fix_ingred_form_16_6_5();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5c8ac8>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5c8e48>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5df7b8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=1/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=2/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=3/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=4/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=5/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=6/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=9/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=12/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=15/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=16/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LINE_SIZE' - False OR  False
[i=16/20][j=8/26][dd=18/23][k=0/2] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : LINE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LINE_SIZE
 => is literal (False) | is operator (False) LINE_SIZE [vtype=None]
----
==== Scope 1 ====
void fix_ingred_form_16_8_0(){
    {char * input_buf; input_buf = (char *)(LINE_SIZE); }
    {int tlv1; tlv1 = (int)(LINE_SIZE); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(LINE_SIZE); }
    {char * tlv5; tlv5 = (char *)(LINE_SIZE); }
    {int tlv2; tlv2 = (int)(LINE_SIZE); }
    {int tlv3; tlv3 = (int)(LINE_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(LINE_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(LINE_SIZE); }
    {void * tlv12; tlv12 = (void *)(LINE_SIZE); }
    {char * tlv14; tlv14 = (char *)(LINE_SIZE); }
    {void * tlv15; tlv15 = (void *)(LINE_SIZE); }
}
void fix_ingred_form_16_8(){
fix_ingred_form_16_8_0();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5d0198>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5d0518>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=1/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
unique : ('char *', 'input_buf', None)
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=2/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=3/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=4/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=5/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=6/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=9/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=12/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=15/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=16/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'input_buf' - False OR  False
[i=16/20][j=9/26][dd=18/23][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : input_buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : input_buf
 => is literal (False) | is operator (False) input_buf [vtype=char *]
not unique: ('char *', 'input_buf', None) ... continue!
not valid - char * input_buf; input_buf = ((char *)input_buf);

----
UNIQ_INIT: ('char *','input_buf','None','None');

==== Scope 1 ====
void fix_ingred_form_16_9_1(){
char input_buf_ref;
    bzero(&input_buf_ref,1*sizeof(char));
char * input_buf = &input_buf_ref;
    {int tlv1; tlv1 = (int)(input_buf); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(input_buf); }
    {char * tlv5; tlv5 = (char *)(input_buf); }
    {int tlv2; tlv2 = (int)(input_buf); }
    {int tlv3; tlv3 = (int)(input_buf); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(input_buf); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(input_buf); }
    {void * tlv12; tlv12 = (void *)(input_buf); }
    {char * tlv14; tlv14 = (char *)(input_buf); }
    {void * tlv15; tlv15 = (void *)(input_buf); }
}
void fix_ingred_form_16_9(){
fix_ingred_form_16_9_1();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('char *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5be748>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c5f0198>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c5f04a8>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=16/20][j=11/26][dd=1/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=16/20][j=11/26][dd=4/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=16/20][j=11/26][dd=9/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=16/20][j=11/26][dd=12/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=16/20][j=11/26][dd=15/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=16/20][j=11/26][dd=16/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=16/20][j=11/26][dd=18/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_form_16_11_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char * input_buf; input_buf = (char *)(tlv1); }
    {char * tlv5; tlv5 = (char *)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv1); }
    {void * tlv12; tlv12 = (void *)(tlv1); }
    {char * tlv14; tlv14 = (char *)(tlv1); }
    {void * tlv15; tlv15 = (void *)(tlv1); }
}
void fix_ingred_form_16_11(){
fix_ingred_form_16_11_1();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('UNDEF', 'cur -> answer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5ccba8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed048>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed518>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed048>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed518>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5e1588>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5e1908>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed048>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed518>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5d6898>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5d6c18>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv12': 'void *'}'
val_s=>'[('void *', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5d5b38>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed048>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ed518>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5d6898>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5d6c18>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=1/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
unique : ('question_t *', 'cur', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=2/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=3/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=4/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=5/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=6/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=9/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=12/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=15/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=16/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=15/26][dd=18/23][k=0/6] | type: void * ; var : tlv12 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
----
UNIQ_INIT: ('question_t *','cur','None','None');

==== Scope 1 ====
void fix_ingred_form_16_15_0(){
question_t cur_ref;
    bzero(&cur_ref,1*sizeof(question_t));
question_t * cur = &cur_ref;
    {char * input_buf; input_buf = (char *)(cur -> answer); }
    {int tlv1; tlv1 = (int)(cur -> answer); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cur -> answer); }
    {char * tlv5; tlv5 = (char *)(cur -> answer); }
    {int tlv2; tlv2 = (int)(cur -> answer); }
    {int tlv3; tlv3 = (int)(cur -> answer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cur -> answer); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cur -> answer); }
    {void * tlv12; tlv12 = (void *)(cur -> answer); }
    {char * tlv14; tlv14 = (char *)(cur -> answer); }
    {void * tlv15; tlv15 = (void *)(cur -> answer); }
}
void fix_ingred_form_16_15(){
fix_ingred_form_16_15_0();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5c7eb8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5f4278>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *'}'
val_s=>'[('UNDEF', 'cur -> answer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5ec908>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5cbc88>), ('question_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c5ec048>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv3': 'int'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv3': 'int', 'tlv11': 'const char *', 'tlv10': 'const char *', 'tlv9': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv3': 'int', 'tlv11': 'const char *', 'tlv10': 'const char *', 'tlv9': 'cgc_size_t', 'tlv17': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c5fa898>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=1/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
unique : ('const char *', 'tlv17', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=2/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=3/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=4/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=5/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=6/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=9/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=12/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=15/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=16/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv17)' - False OR  False
[i=16/20][j=21/26][dd=18/23][k=0/2] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : cgc_strlen ( tlv17 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv17,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv17 [vtype=const char *]
not unique: ('const char *', 'tlv17', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv17','None','None');

==== Scope 1 ====
void fix_ingred_form_16_21_0(){
char tlv17_ref;
    bzero(&tlv17_ref,1*sizeof(char));
const char * tlv17 = &tlv17_ref;
    {char * input_buf; input_buf = (char *)(cgc_strlen ( tlv17 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv17 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv17 )); }
    {char * tlv5; tlv5 = (char *)(cgc_strlen ( tlv17 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv17 )); }
    {int tlv3; tlv3 = (int)(cgc_strlen ( tlv17 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv17 )); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cgc_strlen ( tlv17 )); }
    {void * tlv12; tlv12 = (void *)(cgc_strlen ( tlv17 )); }
    {char * tlv14; tlv14 = (char *)(cgc_strlen ( tlv17 )); }
    {void * tlv15; tlv15 = (void *)(cgc_strlen ( tlv17 )); }
}
void fix_ingred_form_16_21(){
fix_ingred_form_16_21_0();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv3': 'int', 'tlv11': 'const char *', 'tlv10': 'const char *', 'tlv9': 'cgc_size_t'}'
val_s=>'[('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c34a828>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c34aba8>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=16/20][j=22/26][dd=1/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
unique : ('int', 'tlv3', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=16/20][j=22/26][dd=4/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=16/20][j=22/26][dd=9/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=16/20][j=22/26][dd=12/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=16/20][j=22/26][dd=15/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=16/20][j=22/26][dd=16/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=16/20][j=22/26][dd=18/23][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
----
UNIQ_INIT: ('int','tlv3','None','None');

==== Scope 1 ====
void fix_ingred_form_16_22_1(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char * input_buf; input_buf = (char *)(tlv3); }
    {char * tlv5; tlv5 = (char *)(tlv3); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv3); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv3); }
    {void * tlv12; tlv12 = (void *)(tlv3); }
    {char * tlv14; tlv14 = (char *)(tlv3); }
    {void * tlv15; tlv15 = (void *)(tlv3); }
}
void fix_ingred_form_16_22(){
fix_ingred_form_16_22_1();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv3': 'int', 'tlv11': 'const char *', 'tlv10': 'const char *', 'tlv9': 'cgc_size_t', 'tlv14': 'char *', 'tlv13': 'const char *'}'
val_s=>'[('char *', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c353ac8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c34a828>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c34aba8>)]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=1/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
unique : ('question_t *', 'cur', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=2/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=3/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=4/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=5/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=6/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=9/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=12/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=15/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=16/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cur->answer' - False OR  False
[i=16/20][j=23/26][dd=18/23][k=0/4] | type: char * ; var : tlv14 ; varinfo :  ; value_node : cur -> answer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cur,->,answer
 => is literal (False) | is operator (False) cur [vtype=question_t *]
not unique: ('question_t *', 'cur', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) answer [vtype=None]
----
UNIQ_INIT: ('question_t *','cur','None','None');

==== Scope 1 ====
void fix_ingred_form_16_23_0(){
question_t cur_ref;
    bzero(&cur_ref,1*sizeof(question_t));
question_t * cur = &cur_ref;
    {char * input_buf; input_buf = (char *)(cur -> answer); }
    {int tlv1; tlv1 = (int)(cur -> answer); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cur -> answer); }
    {char * tlv5; tlv5 = (char *)(cur -> answer); }
    {int tlv2; tlv2 = (int)(cur -> answer); }
    {int tlv3; tlv3 = (int)(cur -> answer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cur -> answer); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cur -> answer); }
    {void * tlv12; tlv12 = (void *)(cur -> answer); }
    {char * tlv14; tlv14 = (char *)(cur -> answer); }
    {void * tlv15; tlv15 = (void *)(cur -> answer); }
}
void fix_ingred_form_16_23(){
fix_ingred_form_16_23_0();
}

sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv3': 'int', 'tlv11': 'const char *', 'tlv10': 'const char *', 'tlv9': 'cgc_size_t'}'
val_s=>'[('UNDEF', 'cur -> answer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c379d68>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'arg': 'char *', 'cur': 'question_t *', 'input_buf': 'char *', 'tlv4': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'char *', 'tlv3': 'int', 'tlv11': 'const char *', 'tlv10': 'const char *', 'tlv9': 'cgc_size_t', 'tlv15': 'void *'}'
val_s=>'[('void *', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c36dcf8>), ('question_t *', 'cur', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c45c5f8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( cur )' - is_func=True, is_func_ptr=False
cgc_prompt_q( cur ) is a function.
Skipping.
Checking 'cgc_free( input_buf )' - is_func=True, is_func_ptr=False
cgc_free( input_buf ) is a function.
Skipping.
Checking 'cgc_free( tlv12 )' - is_func=True, is_func_ptr=False
cgc_free( tlv12 ) is a function.
Skipping.
Checking 'cgc_free( tlv15 )' - is_func=True, is_func_ptr=False
cgc_free( tlv15 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_form_16_2_0(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {char * input_buf; input_buf = (char *)(arg); }
    {int tlv1; tlv1 = (int)(arg); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(arg); }
    {char * tlv5; tlv5 = (char *)(arg); }
    {int tlv2; tlv2 = (int)(arg); }
    {int tlv3; tlv3 = (int)(arg); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(arg); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(arg); }
    {void * tlv12; tlv12 = (void *)(arg); }
    {char * tlv14; tlv14 = (char *)(arg); }
    {void * tlv15; tlv15 = (void *)(arg); }
}
void fix_ingred_form_16_2_1(){
char arg_ref;
    bzero(&arg_ref,1*sizeof(char));
char * arg = &arg_ref;
    {char * input_buf; input_buf = (char *)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(NULL); }
    {char * tlv5; tlv5 = (char *)(NULL); }
    {int tlv2; tlv2 = (int)(NULL); }
    {int tlv3; tlv3 = (int)(NULL); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NULL); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(NULL); }
    {void * tlv12; tlv12 = (void *)(NULL); }
    {char * tlv14; tlv14 = (char *)(NULL); }
    {void * tlv15; tlv15 = (void *)(NULL); }
}
void fix_ingred_form_16_2(){
fix_ingred_form_16_2_0();
fix_ingred_form_16_2_1();
}
void fix_ingred_form_16_5_0(){
char tlv16_ref;
    bzero(&tlv16_ref,1*sizeof(char));
const char * tlv16 = &tlv16_ref;
    {char * input_buf; input_buf = (char *)(cgc_strlen ( tlv16 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv16 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv16 )); }
    {char * tlv5; tlv5 = (char *)(cgc_strlen ( tlv16 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv16 )); }
    {int tlv3; tlv3 = (int)(cgc_strlen ( tlv16 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv16 )); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cgc_strlen ( tlv16 )); }
    {void * tlv12; tlv12 = (void *)(cgc_strlen ( tlv16 )); }
    {char * tlv14; tlv14 = (char *)(cgc_strlen ( tlv16 )); }
    {void * tlv15; tlv15 = (void *)(cgc_strlen ( tlv16 )); }
}
void fix_ingred_form_16_5(){
fix_ingred_form_16_5_0();
}
void fix_ingred_form_16_6_4(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char * input_buf; input_buf = (char *)(tlv2); }
    {char * tlv5; tlv5 = (char *)(tlv2); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv2); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv2); }
    {void * tlv12; tlv12 = (void *)(tlv2); }
    {char * tlv14; tlv14 = (char *)(tlv2); }
    {void * tlv15; tlv15 = (void *)(tlv2); }
}
void fix_ingred_form_16_6_5(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char * input_buf; input_buf = (char *)(0); }
    {char * tlv5; tlv5 = (char *)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(0); }
    {void * tlv12; tlv12 = (void *)(0); }
    {char * tlv14; tlv14 = (char *)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
}
void fix_ingred_form_16_6(){
fix_ingred_form_16_6_4();
fix_ingred_form_16_6_5();
}
void fix_ingred_form_16_8_0(){
    {char * input_buf; input_buf = (char *)(LINE_SIZE); }
    {int tlv1; tlv1 = (int)(LINE_SIZE); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(LINE_SIZE); }
    {char * tlv5; tlv5 = (char *)(LINE_SIZE); }
    {int tlv2; tlv2 = (int)(LINE_SIZE); }
    {int tlv3; tlv3 = (int)(LINE_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(LINE_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(LINE_SIZE); }
    {void * tlv12; tlv12 = (void *)(LINE_SIZE); }
    {char * tlv14; tlv14 = (char *)(LINE_SIZE); }
    {void * tlv15; tlv15 = (void *)(LINE_SIZE); }
}
void fix_ingred_form_16_8(){
fix_ingred_form_16_8_0();
}
void fix_ingred_form_16_9_1(){
char input_buf_ref;
    bzero(&input_buf_ref,1*sizeof(char));
char * input_buf = &input_buf_ref;
    {int tlv1; tlv1 = (int)(input_buf); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(input_buf); }
    {char * tlv5; tlv5 = (char *)(input_buf); }
    {int tlv2; tlv2 = (int)(input_buf); }
    {int tlv3; tlv3 = (int)(input_buf); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(input_buf); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(input_buf); }
    {void * tlv12; tlv12 = (void *)(input_buf); }
    {char * tlv14; tlv14 = (char *)(input_buf); }
    {void * tlv15; tlv15 = (void *)(input_buf); }
}
void fix_ingred_form_16_9(){
fix_ingred_form_16_9_1();
}
void fix_ingred_form_16_11_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char * input_buf; input_buf = (char *)(tlv1); }
    {char * tlv5; tlv5 = (char *)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv1); }
    {void * tlv12; tlv12 = (void *)(tlv1); }
    {char * tlv14; tlv14 = (char *)(tlv1); }
    {void * tlv15; tlv15 = (void *)(tlv1); }
}
void fix_ingred_form_16_11(){
fix_ingred_form_16_11_1();
}
void fix_ingred_form_16_15_0(){
question_t cur_ref;
    bzero(&cur_ref,1*sizeof(question_t));
question_t * cur = &cur_ref;
    {char * input_buf; input_buf = (char *)(cur -> answer); }
    {int tlv1; tlv1 = (int)(cur -> answer); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cur -> answer); }
    {char * tlv5; tlv5 = (char *)(cur -> answer); }
    {int tlv2; tlv2 = (int)(cur -> answer); }
    {int tlv3; tlv3 = (int)(cur -> answer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cur -> answer); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cur -> answer); }
    {void * tlv12; tlv12 = (void *)(cur -> answer); }
    {char * tlv14; tlv14 = (char *)(cur -> answer); }
    {void * tlv15; tlv15 = (void *)(cur -> answer); }
}
void fix_ingred_form_16_15(){
fix_ingred_form_16_15_0();
}
void fix_ingred_form_16_21_0(){
char tlv17_ref;
    bzero(&tlv17_ref,1*sizeof(char));
const char * tlv17 = &tlv17_ref;
    {char * input_buf; input_buf = (char *)(cgc_strlen ( tlv17 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv17 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv17 )); }
    {char * tlv5; tlv5 = (char *)(cgc_strlen ( tlv17 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv17 )); }
    {int tlv3; tlv3 = (int)(cgc_strlen ( tlv17 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv17 )); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cgc_strlen ( tlv17 )); }
    {void * tlv12; tlv12 = (void *)(cgc_strlen ( tlv17 )); }
    {char * tlv14; tlv14 = (char *)(cgc_strlen ( tlv17 )); }
    {void * tlv15; tlv15 = (void *)(cgc_strlen ( tlv17 )); }
}
void fix_ingred_form_16_21(){
fix_ingred_form_16_21_0();
}
void fix_ingred_form_16_22_1(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char * input_buf; input_buf = (char *)(tlv3); }
    {char * tlv5; tlv5 = (char *)(tlv3); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv3); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv3); }
    {void * tlv12; tlv12 = (void *)(tlv3); }
    {char * tlv14; tlv14 = (char *)(tlv3); }
    {void * tlv15; tlv15 = (void *)(tlv3); }
}
void fix_ingred_form_16_22(){
fix_ingred_form_16_22_1();
}
void fix_ingred_form_16_23_0(){
question_t cur_ref;
    bzero(&cur_ref,1*sizeof(question_t));
question_t * cur = &cur_ref;
    {char * input_buf; input_buf = (char *)(cur -> answer); }
    {int tlv1; tlv1 = (int)(cur -> answer); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cur -> answer); }
    {char * tlv5; tlv5 = (char *)(cur -> answer); }
    {int tlv2; tlv2 = (int)(cur -> answer); }
    {int tlv3; tlv3 = (int)(cur -> answer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cur -> answer); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(cur -> answer); }
    {void * tlv12; tlv12 = (void *)(cur -> answer); }
    {char * tlv14; tlv14 = (char *)(cur -> answer); }
    {void * tlv15; tlv15 = (void *)(cur -> answer); }
}
void fix_ingred_form_16_23(){
fix_ingred_form_16_23_0();
}
void fix_ingred_form_16(){
fix_ingred_form_16_2();
fix_ingred_form_16_5();
fix_ingred_form_16_6();
fix_ingred_form_16_8();
fix_ingred_form_16_9();
fix_ingred_form_16_11();
fix_ingred_form_16_15();
fix_ingred_form_16_21();
fix_ingred_form_16_22();
fix_ingred_form_16_23();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_16_2_0();
void fix_ingred_form_16_2_1();
void fix_ingred_form_16_2();
void fix_ingred_form_16_5_0();
void fix_ingred_form_16_5();
void fix_ingred_form_16_6_4();
void fix_ingred_form_16_6_5();
void fix_ingred_form_16_6();
void fix_ingred_form_16_8_0();
void fix_ingred_form_16_8();
void fix_ingred_form_16_9_1();
void fix_ingred_form_16_9();
void fix_ingred_form_16_11_1();
void fix_ingred_form_16_11();
void fix_ingred_form_16_15_0();
void fix_ingred_form_16_15();
void fix_ingred_form_16_21_0();
void fix_ingred_form_16_21();
void fix_ingred_form_16_22_1();
void fix_ingred_form_16_22();
void fix_ingred_form_16_23_0();
void fix_ingred_form_16_23();
void fix_ingred_form_16();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_print_prompt] : <class 'CParser.CParser.DeclarationContext'> : question_t * tlv1 ;
def_vars[1]: [cgc_print_prompt] : <class 'CParser.CParser.DeclarationContext'> : cgc_prompt_q ( tlv1 ) ;
def_vars[2]: [cgc_print_prompt] : <class 'CParser.CParser.DeclarationContext'> : cgc_print_title ( form ) ;
def_vars[3]: [cgc_print_prompt] : <class 'CParser.CParser.DeclarationContext'> : cgc_print_page ( form ) ;
sym_lut=>'{'form': 'form_t *', 'with_title': 'int', 'done': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_prompt_q( tlv1 )' - is_func=True, is_func_ptr=False
cgc_prompt_q( tlv1 ) is a function.
Skipping.
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
Checking 'cgc_print_page( form )' - is_func=True, is_func_ptr=False
cgc_print_page( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'with_title': 'int', 'done': 'int'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c35f198>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c35f518>)]'
Checking 'cgc_prompt_q( tlv1 )' - is_func=True, is_func_ptr=False
cgc_prompt_q( tlv1 ) is a function.
Skipping.
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
Checking 'cgc_print_page( form )' - is_func=True, is_func_ptr=False
cgc_print_page( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'with_title': 'int', 'done': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_prompt_q( tlv1 )' - is_func=True, is_func_ptr=False
cgc_prompt_q( tlv1 ) is a function.
Skipping.
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
Checking 'cgc_print_page( form )' - is_func=True, is_func_ptr=False
cgc_print_page( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'with_title': 'int', 'done': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_prompt_q( tlv1 )' - is_func=True, is_func_ptr=False
cgc_prompt_q( tlv1 ) is a function.
Skipping.
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
Checking 'cgc_print_page( form )' - is_func=True, is_func_ptr=False
cgc_print_page( form ) is a function.
Skipping.
sym_lut=>'{'form': 'form_t *', 'with_title': 'int', 'done': 'int', 'tlv1': 'question_t *'}'
val_s=>'[('question_t *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c3617b8>)]'
cval_s=>'[]'
Checking 'cgc_prompt_q( tlv1 )' - is_func=True, is_func_ptr=False
cgc_prompt_q( tlv1 ) is a function.
Skipping.
Checking 'cgc_print_title( form )' - is_func=True, is_func_ptr=False
cgc_print_title( form ) is a function.
Skipping.
Checking 'cgc_print_page( form )' - is_func=True, is_func_ptr=False
cgc_print_page( form ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_form_17(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_17();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[1]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : static int tlv1 ;
def_vars[2]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[3]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : form_t * tlv4 ;
def_vars[4]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : char * tlv3 ;
def_vars[5]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv5 = buf ;
def_vars[6]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : form_t * tlv6 ;
def_vars[7]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : form_t * tlv8 ;
def_vars[8]: [cgc_handle_line] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *'}'
val_s=>'[('form_t *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c3583c8>), ('char *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c378358>)]'
cval_s=>'[]'
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=18/20][j=1/14][dd=0/9][k=1/2] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=18/20][j=1/14][dd=4/9][k=1/2] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=18/20][j=1/14][dd=8/9][k=1/2] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
----
UNIQ_INIT: ('char *','buf','None','None');

==== Scope 1 ====
void fix_ingred_form_18_1_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int ret; ret = (int)(buf); }
    {char * tlv3; tlv3 = (char *)(buf); }
    {char * tlv7; tlv7 = (char *)(buf); }
}
void fix_ingred_form_18_1(){
fix_ingred_form_18_1_1();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *'}'
val_s=>'[]'
cval_s=>'[('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c37aba8>), ('form_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c37af28>)]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c36a438>)]'
cval_s=>'[]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=18/20][j=4/14][dd=0/9][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
unique : ('const char *', 'tlv5', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=18/20][j=4/14][dd=2/9][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=18/20][j=4/14][dd=4/9][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=18/20][j=4/14][dd=8/9][k=0/1] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv5','None','None');

==== Scope 1 ====
void fix_ingred_form_18_4_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {char * tlv3; tlv3 = (char *)(cgc_strlen ( tlv5 )); }
    {char * tlv7; tlv7 = (char *)(cgc_strlen ( tlv5 )); }
}
void fix_ingred_form_18_4(){
fix_ingred_form_18_4_0();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c3472e8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c347668>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=18/20][j=5/14][dd=0/9][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
unique : ('cgc_size_t', 'tlv2', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/20][j=5/14][dd=0/9][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=18/20][j=5/14][dd=2/9][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/20][j=5/14][dd=2/9][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=18/20][j=5/14][dd=4/9][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/20][j=5/14][dd=4/9][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=18/20][j=5/14][dd=8/9][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/20][j=5/14][dd=8/9][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
not valid - cgc_size_t tlv2; tlv2 = ((cgc_size_t)tlv2);

----
UNIQ_INIT: ('cgc_size_t','tlv2','None','None');

----
UNIQ_INIT: ('cgc_size_t','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_form_18_5_0(){
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
    {int ret; ret = (int)(tlv2); }
    {char * tlv3; tlv3 = (char *)(tlv2); }
    {char * tlv7; tlv7 = (char *)(tlv2); }
}
void fix_ingred_form_18_5_1(){
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
    {int ret; ret = (int)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {char * tlv3; tlv3 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
}
void fix_ingred_form_18_5(){
fix_ingred_form_18_5_0();
fix_ingred_form_18_5_1();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c3472e8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c347668>)]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *', 'tlv8': 'form_t *', 'tlv7': 'char *'}'
val_s=>'[('form_t *', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c366ba8>), ('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c205b38>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *', 'tlv8': 'form_t *', 'tlv7': 'char *'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c1ff748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c1ffa58>)]'
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=18/20][j=9/14][dd=2/9][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=18/20][j=9/14][dd=4/9][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/20][j=9/14][dd=4/9][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=18/20][j=9/14][dd=8/9][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/20][j=9/14][dd=8/9][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
UNIQ_INIT: ('int','ret','None','None');

----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_form_18_9_0(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(ret); }
    {char * tlv3; tlv3 = (char *)(ret); }
    {char * tlv7; tlv7 = (char *)(ret); }
}
void fix_ingred_form_18_9_1(){
int ret;
    bzero(&ret,sizeof(int));
    {char * tlv3; tlv3 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
}
void fix_ingred_form_18_9(){
fix_ingred_form_18_9_0();
fix_ingred_form_18_9_1();
}

sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *', 'tlv8': 'form_t *', 'tlv7': 'char *'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c1fee48>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14631c209208>)]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *', 'tlv6': 'form_t *'}'
val_s=>'[('form_t *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14631c207a58>)]'
cval_s=>'[]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *', 'tlv6': 'form_t *'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c2134a8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14631c2137b8>)]'
sym_lut=>'{'form': 'form_t *', 'buf': 'char *', 'ret': 'int', 'tlv1': 'static int', 'tlv4': 'form_t *', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'const char *', 'tlv6': 'form_t *'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_18_1_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {int ret; ret = (int)(buf); }
    {char * tlv3; tlv3 = (char *)(buf); }
    {char * tlv7; tlv7 = (char *)(buf); }
}
void fix_ingred_form_18_1(){
fix_ingred_form_18_1_1();
}
void fix_ingred_form_18_4_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {char * tlv3; tlv3 = (char *)(cgc_strlen ( tlv5 )); }
    {char * tlv7; tlv7 = (char *)(cgc_strlen ( tlv5 )); }
}
void fix_ingred_form_18_4(){
fix_ingred_form_18_4_0();
}
void fix_ingred_form_18_5_0(){
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
    {int ret; ret = (int)(tlv2); }
    {char * tlv3; tlv3 = (char *)(tlv2); }
    {char * tlv7; tlv7 = (char *)(tlv2); }
}
void fix_ingred_form_18_5_1(){
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
    {int ret; ret = (int)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {char * tlv3; tlv3 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
}
void fix_ingred_form_18_5(){
fix_ingred_form_18_5_0();
fix_ingred_form_18_5_1();
}
void fix_ingred_form_18_9_0(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(ret); }
    {char * tlv3; tlv3 = (char *)(ret); }
    {char * tlv7; tlv7 = (char *)(ret); }
}
void fix_ingred_form_18_9_1(){
int ret;
    bzero(&ret,sizeof(int));
    {char * tlv3; tlv3 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
}
void fix_ingred_form_18_9(){
fix_ingred_form_18_9_0();
fix_ingred_form_18_9_1();
}
void fix_ingred_form_18(){
fix_ingred_form_18_1();
fix_ingred_form_18_4();
fix_ingred_form_18_5();
fix_ingred_form_18_9();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_18_1_1();
void fix_ingred_form_18_1();
void fix_ingred_form_18_4_0();
void fix_ingred_form_18_4();
void fix_ingred_form_18_5_0();
void fix_ingred_form_18_5_1();
void fix_ingred_form_18_5();
void fix_ingred_form_18_9_0();
void fix_ingred_form_18_9_1();
void fix_ingred_form_18_9();
void fix_ingred_form_18();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'form': 'form_t *'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_form_19(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_form_19();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_form_0_0_0
- fix_ingred_form_0_0
- fix_ingred_form_0_1_1
- fix_ingred_form_0_1_2
- fix_ingred_form_0_1_3
- fix_ingred_form_0_1_4
- fix_ingred_form_0_1
- fix_ingred_form_0_2_1
- fix_ingred_form_0_2_2
- fix_ingred_form_0_2_3
- fix_ingred_form_0_2
- fix_ingred_form_0_3_0
- fix_ingred_form_0_3_1
- fix_ingred_form_0_3
- fix_ingred_form_0_4_0
- fix_ingred_form_0_4
- fix_ingred_form_0_7_0
- fix_ingred_form_0_7
- fix_ingred_form_0_8_4
- fix_ingred_form_0_8
- fix_ingred_form_0
- fix_ingred_form_1_1_0
- fix_ingred_form_1_1
- fix_ingred_form_1
- fix_ingred_form_2_0_1
- fix_ingred_form_2_0
- fix_ingred_form_2_2_0
- fix_ingred_form_2_2
- fix_ingred_form_2
- fix_ingred_form_3_1_0
- fix_ingred_form_3_1
- fix_ingred_form_3
- fix_ingred_form_4_2_0
- fix_ingred_form_4_2
- fix_ingred_form_4_3_0
- fix_ingred_form_4_3_1
- fix_ingred_form_4_3
- fix_ingred_form_4_7_1
- fix_ingred_form_4_7
- fix_ingred_form_4_8_0
- fix_ingred_form_4_8_2
- fix_ingred_form_4_8
- fix_ingred_form_4
- fix_ingred_form_5_5_0
- fix_ingred_form_5_5
- fix_ingred_form_5
- fix_ingred_form_6
- fix_ingred_form_7_1_0
- fix_ingred_form_7_1
- fix_ingred_form_7_2_1
- fix_ingred_form_7_2_2
- fix_ingred_form_7_2
- fix_ingred_form_7_5_1
- fix_ingred_form_7_5
- fix_ingred_form_7_8_1
- fix_ingred_form_7_8
- fix_ingred_form_7
- fix_ingred_form_8
- fix_ingred_form_9
- fix_ingred_form_10
- fix_ingred_form_11
- fix_ingred_form_12
- fix_ingred_form_13
- fix_ingred_form_14
- fix_ingred_form_15
- fix_ingred_form_16_2_0
- fix_ingred_form_16_2_1
- fix_ingred_form_16_2
- fix_ingred_form_16_5_0
- fix_ingred_form_16_5
- fix_ingred_form_16_6_4
- fix_ingred_form_16_6_5
- fix_ingred_form_16_6
- fix_ingred_form_16_8_0
- fix_ingred_form_16_8
- fix_ingred_form_16_9_1
- fix_ingred_form_16_9
- fix_ingred_form_16_11_1
- fix_ingred_form_16_11
- fix_ingred_form_16_15_0
- fix_ingred_form_16_15
- fix_ingred_form_16_21_0
- fix_ingred_form_16_21
- fix_ingred_form_16_22_1
- fix_ingred_form_16_22
- fix_ingred_form_16_23_0
- fix_ingred_form_16_23
- fix_ingred_form_16
- fix_ingred_form_17
- fix_ingred_form_18_1_1
- fix_ingred_form_18_1
- fix_ingred_form_18_4_0
- fix_ingred_form_18_4
- fix_ingred_form_18_5_0
- fix_ingred_form_18_5_1
- fix_ingred_form_18_5
- fix_ingred_form_18_9_0
- fix_ingred_form_18_9_1
- fix_ingred_form_18_9
- fix_ingred_form_18
- fix_ingred_form_19
