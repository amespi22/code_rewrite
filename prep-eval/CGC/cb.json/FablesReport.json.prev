#include "libcgc.h"
#include "cgc_libc.h"
#include "cgc_service.h"
void cgc_newReport(Report * report)
{
    char character;
    character = 0;
    char* string;
     string = NULL;
    short pos;
    pos = 0;
    short prev_pos;
    prev_pos = 0;
    short num_fields;
    num_fields = 0;
    Field* new_field;
    new_field = NULL;
    while (END_CHAR != character) {
	if (SPLIT_CHAR == character) {
	    new_field = cgc_malloc(sizeof(Field));
	    new_field->start = prev_pos - num_fields;
	    new_field->size = pos - prev_pos - 1;
	    new_field->next = report->fields;
	    report->fields = new_field;
	    prev_pos = pos;
	    num_fields++;
	}
	cgc_recv(STDIN, &character, sizeof(character));
	pos++;
    }
    new_field = cgc_malloc(sizeof(Field));
    new_field->start = prev_pos - num_fields;
    new_field->size = pos - prev_pos - 1;
    new_field->next = report->fields;
    report->fields = new_field;
    num_fields++;
    report->record_size = pos - num_fields;
}

void cgc_sendReport(Report * report)
{
    Record* nextRecord;
    nextRecord = NULL;
    int ret;
    ret = 0;
    for (nextRecord = report->head; nextRecord != NULL; nextRecord = nextRecord->next) {
	if (cgc_transmit_all(STDOUT, nextRecord->data, report->record_size)) {
	    cgc__terminate(TRANSMIT_ERROR);
	}
    }
}

void cgc_splitReport(Record * source, Record ** front, Record ** back)
{
    Record *fast;
    Record *slow;
    if (!source || !source->next) {
	*front = source;
	*back = NULL;
    } else {
	slow = source;
	fast = source->next;
	while (fast != NULL) {
	    fast = fast->next;
	    if (fast != NULL) {
		slow = slow->next;
		fast = fast->next;
	    }
	}
	*front = source;
	*back = slow->next;
	slow->next = NULL;
    }
}

Record *cgc_mergeReport(Record * a, Record * b, Field * field)
{
    Record* result;
    result = NULL;
    int compare;
    if (!a) {
	return b;
    }
    if (!b) {
	return a;
    }
    compare = cgc_strncmp(&a->data[field->start], &b->data[field->start], field->size);
    if (compare <= 0) {
	result = a;
 {
     Record* tlv3;
     tlv3 = a -> next;
     Record* tlv2;
     tlv2 = b;
     Field* tlv1;
     tlv1 = field;
    	result->next = cgc_mergeReport(tlv3,tlv2,tlv1);
 }
    } else {
	result = b;
 {
     Record* tlv3;
     tlv3 = a;
     Record* tlv2;
     tlv2 = b -> next;
     Field* tlv1;
     tlv1 = field;
    	result->next = cgc_mergeReport(tlv3,tlv2,tlv1);
 }
    }
    return result;
}

void cgc_sortReport(Record ** headRef, Field * field)
{
    Record* head;
    head = * headRef;
    Record* a;
    a = NULL;
    Record* b;
    b = NULL;
    if (!head || !head->next) {
	return;
    }
    {
        Record* tlv3;
        tlv3 = head;
        Record** tlv2;
        tlv2 = & a;
        Record** tlv1;
        tlv1 = & b;
        cgc_splitReport(tlv3,tlv2,tlv1);
    }
    {
        Record** tlv2;
        tlv2 = & a;
        Field* tlv1;
        tlv1 = field;
        cgc_sortReport(tlv2,tlv1);
    }
    {
        Record** tlv2;
        tlv2 = & b;
        Field* tlv1;
        tlv1 = field;
        cgc_sortReport(tlv2,tlv1);
    }
    {
        Record* tlv3;
        tlv3 = a;
        Record* tlv2;
        tlv2 = b;
        Field* tlv1;
        tlv1 = field;
        *headRef = cgc_mergeReport(tlv3,tlv2,tlv1);
    }
}

void cgc_filterReport(Report * report, Report * filteredReport, char *filterString)
{
    Record* nextRecord;
    nextRecord = NULL;
    Field* nextField;
    nextField = NULL;
    int compare;
    compare = 0;
    for (nextRecord = report->head; nextRecord != NULL; nextRecord = nextRecord->next) {
	for (nextField = report->fields; nextField->next != NULL; nextField = nextField->next) {
	    compare = cgc_strncmp(&nextRecord->data[nextField->start], &filterString[nextField->start], nextField->size);
	    if (!compare) {
		Record *record;
		record = cgc_malloc(sizeof(Record));
		record->next = filteredReport->head;
		record->data = nextRecord->data;
		filteredReport->head = record;
		break;
	    }
	}
    }
}

int cgc_newRecord(Report * report)
{
    Record* record;
    record = NULL;
    short second_field_size;
    second_field_size = 0;
    char* receive_buf;
     receive_buf = NULL;
    Field* nextField;
    nextField = NULL;
    short field_index;
    field_index = 0;
    record = cgc_malloc(sizeof(Record));
    record->next = NULL;
    record->data = cgc_malloc(report->record_size * 2);
    receive_buf = cgc_malloc(report->record_size * 2);
    cgc_memset(record->data, 0, report->record_size);

    for (nextField = report->fields; nextField != NULL; nextField = nextField->next) {
	cgc_memset(receive_buf, 0, report->record_size);
	cgc_recv(STDIN, receive_buf, nextField->size);
	cgc_strcpy(&record->data[field_index], receive_buf);
	field_index += nextField->size;
    }
    cgc_free(receive_buf);
    if (cgc_startswith(record->data, "END")) {
	cgc_free(record->data);
	cgc_free(record);
	return 0;
    } else {
	if (cgc_startswith(record->data, "REPORT")) {
	    cgc_sendReport(report);
	    cgc_free(record->data);
	    cgc_free(record);
	    return 1;
	} else {
	    if (cgc_startswith(record->data, "SORT")) {
		unsigned short field_index;
		Field *key;
		field_index = record->data[sizeof("SORT") - 1];
		for (key = report->fields; key != NULL; key = key->next) {
		    if (field_index == 0) {
			break;
		    }
		    field_index--;
		}
		if (key) {
      {
          Record** tlv2;
          tlv2 = & report -> head;
          Field* tlv1;
          tlv1 = key;
    		    cgc_sortReport(tlv2,tlv1);
      }
		}
		cgc_free(record->data);
		cgc_free(record);
		return 1;
	    } else {
		if (cgc_startswith(record->data, "FREPORT")) {
		    Report filteredReport = { NULL, 0, 0 };
		    filteredReport.record_size = report->record_size;
      {
          Report* tlv3;
          tlv3 = report;
          Report* tlv2;
          tlv2 = & filteredReport;
          char* tlv1;
           tlv1 = record -> data;
    		    cgc_filterReport(tlv3,tlv2,tlv1);
      }
      {
          Report* tlv1;
          tlv1 = & filteredReport;
    		    cgc_sendReport(tlv1);
      }
		    cgc_free(record->data);
		    cgc_free(record);
		    return 1;
		} else {
		    char *command;
		    command = &record->data[report->fields->start];
		    if (cgc_startswith(command, "ERROR")) {
			cgc_free(command);
			cgc_free(record);
			return 1;
		    }
		}
	    }
	}
    }
    record->next = report->head;
    report->head = record;
    return 1;
}

int main(int cgc_argc, char *cgc_argv[])
{
    Report report = { NULL, 0, 0 };
    char* field;
     field = NULL;
    {
        Report* tlv1;
        tlv1 = & report;
        cgc_newReport(tlv1);
    }
    {
    while (cgc_newRecord(&report));
    }
    return 0;
}

